<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Xadmin后台管理系统]]></title>
    <url>%2F2018%2F02%2F24%2FXadmin%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Django 后台管理系统的特点 权限管理 少前端样式：因为首要解决的问题就是快速搭建 快速开发 将UserProfile注册到admin中在admin中的组就是数据库中的表 Django的admin后台管理系统在新建项目的时候就已经自动生成好的，Django的admin也是一个app，会在URL的配置中添加一个admin的链接。 通过createsuperuser 来让我们创建超级用户。Django默认是通过用户名和邮箱进行登录的，可以通过修改来通过邮箱登录。 修改settings.py中的三个参数123456#改为中文LANGUAGE_CODE = &apos;zh-hans&apos;(在Django1.8之后)#修改时区TIME_ZONE = &apos;Asia/Shanghai&apos;#将数据库存储时间改为本地时间USE_TZ = False 在user的admin.py中12345678from .models import UserProfile#UserProfileAdmin通用写法class UserProfileAdmin(admin.ModelAdmin): pass#将UserProfile和UserProfileAdmin关联起来admin.site.register(UserProfile, UserProfileAdmin) 可以看到用户信息的组，上面是model所在的app的名称吗，之后就可以进行表的增删改查。 如果在添加组信息的时候需要修改model，只需要将model修改好，然后makemigrations users(app的名称)就行了。可能会出现一个ValueError：too many values to unpack 原因可能是将所有的app都放在了同一个文件夹中，并且将这个文件夹的名称放进了全局搜索路径。只要将migrations下的文件的路径中去掉文件夹的名称就行了。 安装Xadmin两种安装方式：1、第一种安装方法是直接通过pip安装 在虚拟环境中通过 pip install xadmin 还会帮我们安装完其他的依赖包。然后在settings.py的INSTALLED_APPS中添加’xadmin’，除此之外还需要添加’crispy-forms’，之后将指向admin的URL指向xadmin1234567#urls.pyimport xadminurlpatterns = [ url(&apos;^xadmin/&apos;, xadmin.site.urls),] 最后记得注释掉之前默认的admin的注册方式。 登录到xadmin中出现了 xadmin_usersettings 不存在的错误，原因是因为xadmin有一些默认的表。需要在安装完xadmin后同步过来。直接makemigrations 之后 migrate即可。 2、第二种是通过源码的方式安装的。在GitHub上搜索xadmin下载解压后将文件中的xadmin文件夹添加到项目的根目录之下,因为xadmin也是app，将他放在extra_apps文件夹中。记得要将extra_apps文件夹加入到跟搜索路径中。123456#settings.pyimport osimport sysBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))sys.path.insert(0, os.path.join(BASE_DIR, &apos;extra_apps&apos;)) 将剩余的model注册到xadmin中Django的admin帮我们生成了admin.py文件，我们需要自己创建一个adminx.py文件12345import xadminfrom .models import YourModelNameclass YourModelNameAdmin(object): passxadmin.site.register(YourModelName, YourModelNameAdmin) 如果你想在后台中的表中显示表中的元素就在YourModelNameAdmin中加入1list_display = [&apos;元素1&apos;, &apos;元素2&apos;, &apos;元素3&apos;] 如果你想添加搜索表中元素的功能就在YourModelNameAdmin中加入1search_fields = [&apos;元素1&apos;, &apos;元素2&apos;, &apos;元素3&apos;] 如果你想加入过滤器的功能就在YourModelNameAdmin中加入1list_filter = [&apos;元素1&apos;, &apos;元素2&apos;, &apos;元素3&apos;] 效果图如下： Xadmin的全局配置1、主题功能12345678910#adminx.pyimport xadminfrom xadmin import viewsclass BaseSetting(object): enable_themes = True #默认是关闭的，打开这个功能 use_bootswatch = True #需要与view绑定起来#注册绑定xadmin.site.register(views.BaseAdminView, BaseSetting) 2、修改图中划线两处地方和将左边导航栏中的数据表收起123456789#adminx.pyimport xadminfrom xadmin import viewsclass GlobalSettings(object): site_title = &apos;在线教育后台管理系统&apos; #左上角的划线的字符 site_footer = &apos;在线教育网&apos; #下面划线地方的更改 menu_style = &apos;accordion&apos; #收起左边导航栏的数据表#注册绑定xadmin.site.register(views.CommAdminView, GlobalSettings) 3、自定义app名称1234567#第一步在每个app文件夹下的apps.pyclass YourAppNameConfig(AppConfig): name = &apos;YourAppName&apos; verbose_name = &apos;你的app名称&apos; #加verbose_name即可#第二步在__init__.pydefault_app_config = &apos;YourAppName.apps.YourAppNameConfig&apos;]]></content>
      <categories>
        <category>Django</category>
        <category>在线教育平台</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型和操作数据表]]></title>
    <url>%2F2018%2F02%2F12%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据类型浮点型： FLOAT[(M,D)] DOUBLE[(M,D)] M是数字总位数 D是小数点后面的位数。日期类型： 1234567891011类型 大小(字节) 范围 格式 用途 DATE 4 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 &apos;-838:59:59&apos;/&apos;838:59:59&apos; HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2037 年某时 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 字符类型： 操作数据表数据表（或表）：是数据库最重要的组成部分之一，是其他对象的基础。1234567891011121314151617181920212223242526272829USE 数据库名称;#创建数据表CREATE TABLE [IF NOT EXISTS] table_name ( column_name data_type, ...);#查看数据表SHOW TABLES [FROM db_name] [LIKE &apos;pattern&apos; | WHERE expr];#查看数据表结构SHOW COLUMNS FROM tbl_name;#记录的插入和查找 如果不写列的名字就需要给所有的数据赋值INSERT [INTO] tbl_name [(col_name,...)] VALUES(val,...);SELECT expr,... FROM tbl_name;#空值与非空NULL 字段值可以为空NOT NULL 字段值禁止为空#自动编号AUTO_INCREMENT必须与主键配合使用，默认情况下起始值为1，每次的增量为1#主键每张数据表只能存在一个主键主键保持记录的唯一性主键自动为NOT NULL主键不一定要和AUTO_INCREMENT配合使用主键允许赋值，但是不能相同#唯一约束唯一约束可以保证记录的唯一性唯一约束的字段可以为空值每张数据表可以存在多个唯一约束]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL初涉]]></title>
    <url>%2F2018%2F02%2F11%2FMySQL%E5%88%9D%E6%B6%89%2F</url>
    <content type="text"><![CDATA[启动和停止MySQL1234#启动MySQLnet start mysql#停止MySQLnet stop mysql 登录和退出mysql的参数1234567891011121314-D, --database=name 打开指定数据库--delimiter = name 指定分隔符-h, --host=name 服务器名称-p, --password[=name] 密码-P, --port=# 端口号--prompt=name 设置提示符-u, --user=name 用户名-V, --version 输出版本信息并且退出#登录mysql -u username -p#退出mysql &gt; exit;mysql &gt; quit;mysql &gt; \q; 修改MySQL提示符1、连接客户端时通过参数指定shell&gt;mysql -uroot -proot –prompt 提示符 2、连接上客户端后，通过prompt命令修改mysql&gt;prompt 提示符 12345#MySQL提示符\D 完整的日期\d 当前的数据库\h 服务器名称\u 当前用户 MySQL常用命令123456#显示当前服务器版本SELECT VERSION();#显示当前日期时间SELECT NOW();#显示当前用户SELECT USER(); MySQL语句的规范 关键字和函数名称全部大写 数据库名称、表名称、字段名称全部小写 SQL语句必须以分号结尾 数据库操作12345678910111213#创建数据库#&#123;&#125;表示必选项 里面的两个选项是完全相同的，两个任选其一就行# IF NOT EXISTS 如果创建的数据库已经产生，那么会忽略掉错误的，只会报一条警告信息 SHOW WARNINGS;查询警告信息#[]表示可选项#[DEFAULT] CHARACTER SET [=] charset_name 表示数据库默认的编码方式 SHOW CREATE DATABASE 数据库名称;查看创建数据库的语句。CREATE &#123;DATEBASE | SCHEMA&#125; [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset_name#查看当前服务器下的数据表列表SHOW &#123;DATABASES | SCHEMA&#125; [LIKE &apos;pattern&apos; | WHERE expr]#修改数据库ALTER &#123;DATEBASE | SCHEMA&#125; db_name [DEFAULT] CHARACTER SET [=] charset_name#删除数据库DROP &#123;DATEBASE | SCHEMA&#125; [IF EXISTS] db_name]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与用户交互的表单标签]]></title>
    <url>%2F2018%2F02%2F11%2F%E4%B8%8E%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%E7%9A%84%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[form表单网站利用HTML表单和用户进行交互。表单是可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。语法： 12345&lt;form method=&quot;传送方式&quot; action=&quot;服务器文件&quot;&gt;#form:表单成对出现 &lt;form&gt;开始，&lt;/form&gt;结束#action:浏览者输入的数据被传送到的地方。#method:数据传送的方式。（get/post）注意：所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 &lt;form&gt;&lt;/form&gt; 标签之间（否则用户输入的信息可提交不到服务器上）。 文本输入框、密码输入框当用户要在表单中键入字母、数字等内容时，就会用到文本输入框。文本框也可以转化为密码输入框。语法：123&lt;form&gt; &lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot; /&gt;&lt;/form&gt; 1、type：当type=”text”时，输入框为文本输入框;当type=”password”时, 输入框为密码输入框。2、name：为文本框命名，以备后台程序ASP 、PHP使用。3、value：为文本输入框设置默认值。(一般起到提示作用) 文本域，支持多行文本输入语法：12345&lt;textarea rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;文本&lt;/textarea&gt;1、&lt;textarea&gt;标签是成对出现的，以&lt;textarea&gt;开始，以&lt;/textarea&gt;结束。2、cols ：多行输入域的列数。3、rows ：多行输入域的行数。4、在&lt;textarea&gt;&lt;/textarea&gt;标签之间可以输入默认值。 在这里如果定义了cols和rows的话可以自定义输入框的大小。 单选框 复选框语法：1234567&lt;input type=&quot;radio/checkbox&quot; value=&quot;值&quot; name=&quot;名称&quot; checked=&quot;checked&quot;/&gt;1、type: 当 type=&quot;radio&quot; 时，控件为单选框 当 type=&quot;checkbox&quot; 时，控件为复选框2、value：提交数据到服务器的值（后台程序PHP使用）3、name：为控件命名，以备后台程序 ASP、PHP 使用4、checked：当设置 checked=&quot;checked&quot; 时，该选项被默认选中 注意： 同一组的单选按钮，name 取值一定要一致，比如上面例子为同一个名称“radioLove”，这样同一组的单选按钮才可以起到单选的作用。 下拉列表框有效节省网页空间，既可以单选也可以多选。123456789&lt;form action=&quot;save.php&quot; method=&quot;post&quot; &gt; &lt;label&gt;爱好:&lt;/label&gt; &lt;select&gt; &lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt; &lt;option value=&quot;旅游&quot; selected=&quot;selected&quot;&gt;旅游&lt;/option&gt; &lt;option value=&quot;运动&quot;&gt;运动&lt;/option&gt; &lt;option value=&quot;购物&quot;&gt;购物&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; 下拉列表也可以进行多选操作，在select标签中设置multiple=”multiple”属性，就可以实现多选功能，在 windows 操作系统下，进行多选时按下Ctrl键同时进行单 击（在 Mac下使用 Command +单击），可以选择多个选项。 提交按钮在表单中有两种按钮可以使用，分别为：提交按钮、重置。当用户需要提交表单信息到服务器时，需要用到提交按钮。语法：1234567&lt;form method=&quot;post&quot; action=&quot;save.php&quot;&gt; &lt;label for=&quot;myName&quot;&gt;姓名：&lt;/label&gt; &lt;input type=&quot;text&quot; value=&quot; &quot; name=&quot;myName &quot; /&gt; &lt;input type=&quot;text&quot; value=&quot;提交&quot; name=&quot;submitBtn&quot; /&gt;&lt;/form&gt;type：只有当type值设置为submit时，按钮才有提交作用value：按钮上显示的文字 重置按钮当用户需要重置表单信息到初始时的状态时，可以使用重置按钮使输入框恢复到初始状态。只需要把type设置为”reset”就可以。 label标签label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。1234567&lt;form&gt; &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;male&quot; /&gt; &lt;br /&gt; &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;female&quot; /&gt;&lt;/form&gt; 标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标签(第三部分)]]></title>
    <url>%2F2018%2F02%2F11%2F%E6%A0%87%E7%AD%BE-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[a标签利用a标签 链接到另外一个页面。语法：1&lt;a href=&quot;目标网址&quot; title=&quot;鼠标滑过显示的文本&quot;&gt;链接显示的文本&lt;/a&gt; title属性的作用，鼠标滑过链接文字时会显示这个属性的文本内容。这个属性在实际网页开发中作用很大，主要方便搜索引擎了解链接地址的内容（语义化更友好）。a标签在默认的情况下，链接的网页是在当前浏览器窗口中打开，如果需要在新的窗口打开的话： 1&lt;a href=&quot;目标网址&quot; target=&quot;_blank&quot;&gt;click here!&lt;/a&gt; 除了上面两种功能之外，a标签的另外一个作用就是可以链接Email地址，使用mailto能让访问者便捷的向网站管理者发送电子邮件。具体可以看下图： 注意：如果mailto后面同时有多个参数的话，第一个参数必须以”?”开头，后面的参数每一个都以”&amp;”分隔。 1&lt;a href=&quot;mailto:yy@imooc.com?cc=aa@imooc.com&amp;bcc=bb@imooc.com&amp;subject=主题&amp;body=邮件内容&quot;&gt;发送&lt;/a&gt; 点击链接会打开电子邮件应用，并自动填写收件人等设置好的信息。 img标签语法：1&lt;img src=&quot;图片地址&quot; alt=&quot;下载失败时的替换文本&quot; title = &quot;提示文本&quot;&gt; 1、src：标识图像的位置2、alt：指定图像的描述性文本，当图像不可见时（下载不成功时），可看到该属性指定的文本3、title：提供在图像可见时对图像的描述(鼠标滑过图片时显示的文本)4、图像可以是GIF，PNG，JPEG格式的图像文件]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标签(第二部分)]]></title>
    <url>%2F2018%2F02%2F11%2F%E6%A0%87%E7%AD%BE-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[ul标签 信息列表在浏览网页的时候有很多的新闻列表、图片列表，这些列表就可以用ul-li来完成。ul-li是没有前后顺序的信息列表,在网页中的样式默认为：每项li前面都自带一个圆点。语法： 12345&lt;ul&gt; &lt;li&gt;信息&lt;/li&gt; &lt;li&gt;信息&lt;/li&gt; ......&lt;/ul&gt; ol 有序列表语法： 12345&lt;ol&gt; &lt;li&gt;信息&lt;/li&gt; &lt;li&gt;信息&lt;/li&gt; ......&lt;/ol&gt; 在网页中显示的默认样式一般为：每项li前都自带一个序号，序号默认从1开始1231. ...2. ...3. ... div标签在制作网页的过程中，可以将独立的逻辑部分划分出来，放在一个div标签中，这些标签的作用就相当于一个容器。语法：1&lt;div&gt;...&lt;/div&gt; 为了使逻辑更加清晰，我们可以将一个独立的逻辑部分设置成一个名称，用id属性来给div标签提供唯一的名称。语法： 1&lt;div id=&quot;版块名称&quot;&gt;...&lt;/div&gt; table标签作用：在网页上显示表格1234567891011121314151617创建表格的四个元素：table、tbody、tr、th、td1、&lt;table&gt;…&lt;/table&gt;：整个表格以&lt;table&gt;标记开始、&lt;/table&gt;标记结束。2、&lt;tbody&gt;…&lt;/tbody&gt;：如果不加&lt;thead&gt;&lt;tbody&gt;&lt;tfooter&gt; , table表格加载完后才显示。加上这些表格结构， tbody包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用tbody分段，可以一部分一部分地显示。（通俗理解table 可以按结构一块块的显示，不在等整个表格加载完后显示。）3、&lt;tr&gt;…&lt;/tr&gt;：表格的一行，所以有几对tr 表格就有几行。4、&lt;td&gt;…&lt;/td&gt;：表格的一个单元格，一行中包含几对&lt;td&gt;...&lt;/td&gt;，说明一行中就有几列。5、&lt;th&gt;…&lt;/th&gt;：表格的头部的一个单元格，表格表头。6、表格中列的个数，取决于一行中数据单元格的个数。 注意：1、table表格在没有添加css样式之前，在浏览器中显示是没有表格线的2、表头，也就是th标签中的文本默认为粗体并且居中显示 1234567891011121314151617181920212223242526&lt;body&gt;&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;学生数&lt;/th&gt; &lt;th&gt;平均成绩&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;一班&lt;/td&gt; &lt;td&gt;30&lt;/td&gt; &lt;td&gt;89&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;二班&lt;/td&gt; &lt;td&gt;35&lt;/td&gt; &lt;td&gt;85&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;三班&lt;/td&gt; &lt;td&gt;32&lt;/td&gt; &lt;td&gt;80&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt; 为表格添加标题和摘要摘要：摘要的内容是不会在浏览器中显示出来的。它的作用是增加表格的可读性(语义化)，使搜索引擎更好的读懂表格内容，还可以使屏幕阅读器更好的帮助特殊用户读取表格内容。 1&lt;table summary=&quot;表格简介文本&quot;&gt; 标题:用以描述表格内容，标题的显示位置：表格上方。 12345678910&lt;table&gt;&lt;table summary=&quot;摘要&quot;&gt; &lt;caption&gt;标题文本&lt;/caption&gt; &lt;tr&gt; &lt;td&gt;…&lt;/td&gt; &lt;td&gt;…&lt;/td&gt; … &lt;/tr&gt;…&lt;/table&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标签(第一部分)]]></title>
    <url>%2F2018%2F02%2F10%2F%E6%A0%87%E7%AD%BE(%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86)%2F</url>
    <content type="text"><![CDATA[body标签在网页上要展示出来的页面内容一定要放在body标签中。 p标签如果想在网页上显示文章，这时就需要p标签了，把文章的段落放到p标签中。语法：1&lt;p&gt;段落文本&lt;/p&gt; 注意一段文字一个p标签，如在一篇新闻文章中有3段文字，就要把这3个段落分别放到3个p标签中。 hx标签123456文章的段落用&lt;p&gt;标签，那么文章的标题用什么标签呢？在本节我们将使用&lt;hx&gt;标签来制作文章的标题。标题标签一共有6个，h1、h2、h3、h4、h5、h6分别为一级标题、二级标题、三级标题、四级标题、五级标题、六级标题。并且依据重要性递减。&lt;h1&gt;是最高的等级。语法：&lt;hx&gt;标题文本&lt;/hx&gt; (x为1-6)文章的标题可以使用标题标签，另外网页上的各个栏目的标题也可使用它们。注意：因为h1标签在网页中比较重要，所以一般h1标签被用在网站名称上。 strong 和 em 标签123#&lt;em&gt; 表示强调，&lt;strong&gt; 表示更强烈的强调。并且在浏览器中&lt;em&gt; 默认用斜体表示，&lt;strong&gt; 用粗体表示。&lt;em&gt;需要强调的文本&lt;/em&gt;&lt;strong&gt;需要强调的文本&lt;/strong&gt; span标签span标签是没有语义的，它的作用就是为了设置单独的样式用的。如果现在我们想把上一小节的第一段话“美国梦”三个字设置成blue（蓝色），但注意不是为了强调“美国梦”，而只是想为它设置和其它文字不同的样式（并不想让屏幕阅读器对“美国梦”这三个字加重音读出），所以这样情况下就可以用到标签了。123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;了不起的盖茨比&lt;/title&gt;&lt;style&gt;span&#123; color:blue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;1922年的春天，一个想要成名名叫尼克•卡拉威（托比•马奎尔Tobey Maguire 饰）的作家，离开了美国中西部，来到了纽约。 那是一个道德感渐失，爵士乐流行，走私为王，股票飞涨的时代。为了追寻他的&lt;span&gt;美国梦&lt;/span&gt;，他搬入纽约附近一海湾居住。&lt;/p&gt; &lt;p&gt;菲茨杰拉德，二十世纪美国文学巨擘之一，兼具作家和编剧双重身份。 他以诗人的敏感和戏剧家的想象为&quot;爵士乐时代&quot;吟唱华丽挽歌，其诗人和梦想家的气质亦为那个奢靡年代的不二注解。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; q标签和blockquote标签q标签作用：短文本引用1&lt;q&gt;引用文本&lt;/q&gt; 注意：要引用的文本不用加双引号，浏览器会对q标签自动添加双引号。 blockquote标签的作用也是引用别人的文本，但是它是对长文本的引用。 br标签123456如果想让一首诗的每一句诗词后面都有一个折行，那就可以用到&lt;br /&gt;标签了，在需要加回车换行的地方加入&lt;br /&gt;，&lt;br /&gt;标签作用相当于word文档中的回车。xhtml1.0写法：&lt;br /&gt;html4.01写法：&lt;br&gt; 现在一般使用 xhtml1.0 的版本的写法（其它标签也是），这种版本比较规范。 在HTML中输入空格要想输入空格，必须写入1&amp;nbsp; hr标签在信息展示时，有时会需要加一些用于分隔的横线，这样会使文章看起来整齐些。语法：123456html4.01版本 &lt;hr&gt;xhtml1.0版本 &lt;hr /&gt;注意：1. &lt;hr /&gt;标签和&lt;br /&gt;标签一样也是一个空标签，所以只有一个开始标签，没有结束标签。2. &lt;hr /&gt;标签的在浏览器中的默认样式线条比较粗，颜色为灰色，可能有些人觉得这种样式不美观，没有关系，这些外在样式在我们以后学习了css样式表之后，都可以对其修改。3. 大家注意，现在一般使用 xhtml1.0 的版本（其它标签也是），这种版本比较规范。 address标签一般网页中会有一些网站的联系地址信息需要在网页中展示出来，这些联系地址信息如公司的地址就可以address标签。也可以定义一个地址（比如电子邮件地址）、签名或者文档的作者身份。语法： 1&lt;address&gt;联系地址信息&lt;/address&gt; 在浏览器上显示的样式为斜体，如果不喜欢斜体，可以在以后使用css样式来修改它默认样式。 code和pre标签作用：在HTML中显示一行代码。语法： 1&lt;code&gt;你的代码&lt;/code&gt; 多行代码的话，就需要使用pre标签。pre标签的语法： 1&lt;pre&gt;语言代码段&lt;/pre&gt; 主要作用:预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。 1234567&lt;body&gt;var message=&quot;欢迎&quot;;for(var i=1;i&lt;=10;i++)&lt;br&gt;&#123;&lt;br&gt; alert(message); &lt;br&gt;&#125;&lt;br&gt;&lt;/body&gt; 加入pre标签应该去掉原本的br标签 123456789&lt;body&gt;&lt;pre&gt;var message=&quot;欢迎&quot;;for(var i=1;i&lt;=10;i++)&#123; alert(message);&#125;&lt;pre&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html介绍]]></title>
    <url>%2F2018%2F02%2F10%2Fhtml%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[慕课网传送门 html css js HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。 CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。 JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。 1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;Html和CSS的关系&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; h1&#123; font-size:12px; color:#930; text-align:center; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; font-size是修改字号，color是修改字体颜色，text-align是调整字体位置，center居中，left最左，right最右 标签的语法123456781. 标签由英文尖括号&lt;和&gt;括起来，如&lt;html&gt;就是一个标签。2. html中的标签一般都是成对出现的，分开始标签和结束标签。结束标签比开始标签多了一个/。如：&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt;3. 标签与标签之间是可以嵌套的，但先后顺序必须保持一致，如：&lt;div&gt;里嵌套&lt;p&gt;，那么&lt;/p&gt;必须放在&lt;/div&gt;的前面。4. HTML标签不区分大小写，&lt;h1&gt;和&lt;H1&gt;是一样的，但建议小写，因为大部分程序员都以小写为准。 html文件基础结构这一节中我们来学习html文件的结构：一个HTML文件是有自己固定的结构的。1234567&lt;html&gt; &lt;head&gt;...&lt;/head&gt; &lt;body&gt;...&lt;/body&gt;&lt;/html&gt;1. &lt;html&gt;&lt;/html&gt;称为根标签，所有的网页标签都在&lt;html&gt;&lt;/html&gt;中。2. &lt;head&gt; 标签用于定义文档的头部，它是所有头部元素的容器。头部元素有&lt;title&gt;、&lt;script&gt;、 &lt;style&gt;、&lt;link&gt;、 &lt;meta&gt;等标签。3. 在&lt;body&gt;和&lt;/body&gt;标签之间的内容是网页的主要内容，如&lt;h1&gt;、&lt;p&gt;、&lt;a&gt;、&lt;img&gt;等网页内容标签，在这里的标签中的内容会在浏览器中显示出来。 head标签12345678910111213141516171819文档的头部描述了文档的各种属性和信息，包括文档的标题等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。下面这些标签可用在 head 部分：&lt;head&gt; &lt;title&gt;...&lt;/title&gt; &lt;meta&gt; &lt;link&gt; &lt;style&gt;...&lt;/style&gt; &lt;script&gt;...&lt;/script&gt;&lt;/head&gt;&lt;title&gt;标签：在&lt;title&gt;和&lt;/title&gt;标签之间的文字内容是网页的标题信息，它会出现在浏览器的标题栏中。网页的title标签用于告诉用户和搜索引擎这个网页的主要内容是什么，搜索引擎可以通过网页标题，迅速的判断出网页的主题。每个网页的内容都是不同的，每个网页都应该有一个独一无二的title。例如：&lt;head&gt; &lt;title&gt;hello world&lt;/title&gt;&lt;/head&gt;标签的内容“hello world”会在浏览器中的标题栏上显示出来 代码注释代码注释的作用是帮助程序员标注代码的用途，过一段时间后再看你所编写的代码，就能很快想起这段代码的用途。代码注释不仅方便程序员自己回忆起以前代码的用途，还可以帮助其他程序员很快的读懂你的程序的功能，方便多人合作开发网页代码。 语法：1&lt;!--注释文字 --&gt; 注释代码是不会在结果窗口中显示出来的。 语义化标签的用途：我们学习网页制作时，常常会听到一个词，语义化。那么什么叫做语义化呢，说的通俗点就是：明白每个标签的用途（在什么情况下使用此标签合理）比如，网页上的文章的标题就可以用标题标签，网页上的各个栏目的栏目名称也可以使用标题标签。文章中内容的段落就得放在段落标签中，在文章中有想强调的文本，就可以使用 em 标签表示强调等等。语义化可以给我们带来什么样的好处呢？ 更容易被搜索引擎收录。 更容易让屏幕阅读器读出网页内容。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[url和templates配置]]></title>
    <url>%2F2018%2F02%2F10%2Furl%E5%92%8Ctemplates%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[将数据库中的值显示到html中在views.py 中的render中是可以带参数的1234from .models import UserMessagedef getfrom(request): message = UserMessage.objects.filter(name=&quot;yourname&quot;) return render(request, &quot;message_form.html&quot;,&#123;&quot;my_message&quot;:message&#125;) 在HTML的template模板中不能写入过多的Python逻辑便于后期的维护 添加value即可12345&lt;label&gt; &lt;span&gt;联系地址 :&lt;/span&gt; &lt;input id=&quot;adress&quot; type=&quot;text&quot; value=&quot;&#123;&#123; my_message.address &#125;&#125;&quot; etc./&gt; &lt;div class=&quot;error-msg&quot;&gt;&lt;/div&gt;&lt;/label&gt; 更多的template内置函数在传送门 url配置第一点要注意的就是：在urls.py 中在后面添加一个name1234urlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^form/$&apos;, getform, name=&apos;go_form&apos;)] 这样做的好处是，便于在template中用到内置的函数，简化操作。原先在HTML中配置URL是这样的：1&lt;form action=&quot;/form/&quot; method=...&gt; 有了name之后，就可以这么操作：1&lt;form action=&quot;&#123;% url &apos;go_form&apos;&apos;%&#125;&quot; method=...&gt; 这么做的好处就是，如果以后1url(r&apos;^form/$&apos;, getform, name=&apos;go_form&apos;) 中的form改为别的，我就不至于再到HTML页面中改我的URL路径，因为我用到的是它的别名。第二点要注意的是：在配置URL的时候一定要加上/和$符号，防止URL冲突。1url(r&apos;^form/$&apos;, getform, name=&apos;go_form&apos;)]]></content>
      <categories>
        <category>Django</category>
        <category>在线教育平台</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[models的增删改查]]></title>
    <url>%2F2018%2F02%2F09%2Fmodels%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[views知识点 HttpRequest 和HttpResponseHTTP请求：HttpRequestHTTP响应：HttpResponse在django.http中。其中：GET在views.py中调用request.GET.get(“参数名”)来接收传进来的参数。在浏览器中用\?来传递参数POST 表单post提交，使用POST接收。注意，表单中的变量名要和views.py中get方法的变量名一样。123456#form 表单&lt;form method=&quot;post&quot; action=&quot;/hello/&quot;&gt;&lt;% csrf_token %&gt; &lt;input type=&quot;text&quot; value=&quot;&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 12#views.pyrequest.POST.get(&quot;name&quot;) 使用get提交,GET接收123456#form 表单&lt;form method=&quot;get&quot; action=&quot;/hello/&quot;&gt;&lt;% csrf_token %&gt; &lt;input type=&quot;text&quot; value=&quot;&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 12#views.pyrequest.GET.get(&quot;name&quot;) HttpRequest对象的属性和方法12345678910111213141516171819202122232425262728293031323334353637383940414243# path： 请求页面的全路径，不包括域名## method： 请求中使用的HTTP方法的字符串表示。全大写表示。例如## if req.method==&quot;GET&quot;:## do_something()## elseif req.method==&quot;POST&quot;:## do_something_else()## GET: 包含所有HTTP GET参数的类字典对象## POST： 包含所有HTTP POST参数的类字典对象## 服务器收到空的POST请求的情况也是可能发生的，也就是说，表单form通过# HTTP POST方法提交请求，但是表单中可能没有数据，因此不能使用# if req.POST来判断是否使用了HTTP POST 方法；应该使用 if req.method==&quot;POST&quot;#### COOKIES: 包含所有cookies的标准Python字典对象；keys和values都是字符串。## FILES： 包含所有上传文件的类字典对象；FILES中的每一个Key都是&lt;input type=&quot;file&quot; name=&quot;&quot; /&gt;标签中 name属性的值，FILES中的每一个value同时也是一个标准的python字典对象，包含下面三个Keys：## filename： 上传文件名，用字符串表示# content_type: 上传文件的Content Type# content： 上传文件的原始内容### user： 是一个django.contrib.auth.models.User对象，代表当前登陆的用户。如果访问用户当前# 没有登陆，user将被初始化为django.contrib.auth.models.AnonymousUser的实例。你# 可以通过user的is_authenticated()方法来辨别用户是否登陆：# if req.user.is_authenticated();只有激活Django中的AuthenticationMiddleware# 时该属性才可用## session： 唯一可读写的属性，代表当前会话的字典对象；自己有激活Django中的session支持时该属性才可用。#方法get_full_path(), 比如：http://127.0.0.1:8000/index33/?name=123 ,req.get_full_path()得到的结果就是/index33/?name=123req.path:/index33#注意一个常用方法：request.POST.getlist(&apos;&apos;) HTTPResponse对象对于HttpRequest对象来说，是由django自动创建的，但是，HttpResponse对象就必须我们自己创建。每个view请求处理方法必须返回一个HttpResponse对象。HttpResponse类在django.http.HttpResponse在HttpResponse对象上扩展的常用方法：12345页面渲染： render()（推荐）&lt;br&gt; render_to_response(),页面跳转： redirect(&quot;路径&quot;)locals()： 可以直接将函数中所有的变量传给模板 models 的增删改查查123456from .models import UserMessagedef getfrom(request): all_messages = UserMessage.objects.all() for message in all_messages: print(message.name) #message = UserMessage.objects.filter(name=&quot;yourname&quot;) 增12345from .models import UserMessagedef getfrom(request): user_message = UserMessage() user_message.name = &quot;北斗小辣椒&quot; user_message.save() 在对form表单提交的时候，会出现403的错误，原因就是Django的一种安全机制，解决方法就是在html中的form表单中添加1&#123;% csrf_token %&#125; 删12345678from .models import UserMessagedef getfrom(request): all_messages = UserMessage.objects.all() #删除全部 all_messages.delete() for message in all_messages: #删除一条 message.delete() 改 类似]]></content>
      <categories>
        <category>Django</category>
        <category>在线教育平台</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MODEl之meta选项]]></title>
    <url>%2F2018%2F02%2F07%2FMODEl%E4%B9%8Bmeta%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[Django 通过内嵌类class meta来给model类定义元数据（不是一个字段的任何数据” – 比如排序选项, admin 选项等等。元数据是可选的）12345class Foo(models.Model): bar = models.CharField(maxlength=30) class Meta: # ... app_labelapp_label这个选项只在一种情况下使用，就是你的模型类不在默认的应用程序包下的models.py文件中，这时候你需要指定你这个模型类是那个应用程序的。比如你在其他地方写了一个模型类，而这个模型类是属于myapp的，那么你这是需要指定为：1app_label=&apos;myapp&apos; db_tabledb_table是用于指定自定义数据库表名的。Django有一套默认的按照一定规则生成数据模型对应的数据库表名，如果你想使用自定义的表名，就通过这个属性指定，比如：1table_name=&apos;my_owner_table&apos; 若不提供该参数, Django 会使用 applabel + ‘‘ + module_name 作为表的名字。若你的表的名字是一个 SQL 保留字, 或包含 Python 变量名不允许的字符–特别是连字符 –没关系. Django 会自动在幕后替你将列名字和表名字用引号引起来. db_tablespace有些数据库有数据库表空间，比如Oracle。你可以通过db_tablespace来指定这个模型对应的数据库表放在哪个数据库表空间。 get_latest_by由于Django的管理方法中有个lastest()方法，就是得到最近一行记录。如果你的数据模型中有 DateField 或 DateTimeField 类型的字段，你可以通过这个选项来指定lastest()是按照哪个字段进行选取的。一个 DateField 或 DateTimeField 字段的名字. 若提供该选项, 该模块将拥有一个 get_latest() 函数以得到 “最新的” 对象(依据那个字段):1get_latest_by = &quot;order_date&quot; get_latest_by由于Django的管理方法中有个lastest()方法，就是得到最近一行记录。如果你的数据模型中有 DateField 或 DateTimeField 类型的字段，你可以通过这个选项来指定lastest()是按照哪个字段进行选取的。一个 DateField 或 DateTimeField 字段的名字. 若提供该选项, 该模块将拥有一个 get_latest() 函数以得到 “最新的” 对象(依据那个字段):1get_latest_by = &quot;order_date&quot; order_with_respect_to这个选项一般用于多对多的关系中，它指向一个关联对象。就是说关联对象找到这个对象后它是经过排序的。指定这个属性后你会得到一个get_XXX_order()和set_XXX_order（）的方法,通过它们你可以设置或者回去排序的对象。 举例来说, 如果一个 PizzaToppping 关联到一个 Pizza 对象, 这样做:1order_with_respect_to = &apos;pizza&apos; 就允许 toppings 依照相关的 pizza 来排序。 ordering这个字段是告诉Django模型对象返回的记录结果集是按照哪个字段排序的。比如下面的代码：12345678ordering=[&apos;order_date&apos;]# 按订单升序排列ordering=[&apos;-order_date&apos;]# 按订单降序排列，-表示降序ordering=[&apos;?order_date&apos;]# 随机排序，？表示随机ordering = [&apos;-pub_date&apos;, &apos;author&apos;]# 对 pub_date 降序,然后对 author 升序 需要注意的是:不论你使用了多少个字段排序, admin 只使用第一个字段 permissionspermissions主要是为了在Django Admin管理模块下使用的，如果你设置了这个属性可以让指定的方法权限描述更清晰可读。 要创建一个对象所需要的额外的权限. 如果一个对象有 admin 设置, 则每个对象的添加,删除和改变权限会人(依据该选项)自动创建.下面这个例子指定了一个附加权限: can_deliver_pizzas:1permissions = ((&quot;can_deliver_pizzas&quot;, &quot;Can deliver pizzas&quot;),) 这是一个2-元素 tuple 的tuple或列表, 其中两2-元素 tuple 的格式为:1(permission_code, human_readable_permission_name). unique_togetherunique_together这个选项用于：当你需要通过两个字段保持唯一性时使用。这会在 Django admin 层和数据库层同时做出限制(也就是相关的 UNIQUE 语句会被包括在 CREATE TABLE 语句中)。比如：一个Person的FirstName和LastName两者的组合必须是唯一的，那么需要这样设置：1unique_together = ((&quot;first_name&quot;, &quot;last_name&quot;),) verbose_name 和 verbose_name_pluralverbose_name的意思很简单，就是给你的模型类起一个更可读的名字：1verbose_name = &quot;pizza&quot; 若未提供该选项, Django 则会用一个类名字的 munged 版本来代替: CamelCase becomes camel case.verbose_name_plural这个选项是指定，模型的复数形式是什么，比如：1verbose_name_plural = &quot;stories&quot; 若未提供该选项, Django 会使用 verbose_name + “s”.]]></content>
      <categories>
        <category>Django</category>
        <category>在线教育平台</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django orm 和 model设计]]></title>
    <url>%2F2018%2F02%2F06%2Fdjango-orm-%E5%92%8C-model%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[ORM ORM的简介 对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。 ORM提供了实现持久化层的另一种模式，它采用映射元数据来描述对象关系的映射，使得ORM中间件能在任何一个应用的业务逻辑层和数据库层之间充当桥梁。 元数据是描述其它数据的数据 （data about other data），或者说是用于提供某种资源的有关信息的结构数据（structured data）。元数据是描述信息资源或数据等对象的数据，其使用目的在于：识别资源；评价资源；追踪资源在使用过程中的变化；实现简单高效地管理大量网络化数据；实现信息资源的有效发现、查找、一体化组织和对使用资源的有效管理。 ORM的方法论基于三个核心原则： 1. 简单：以最基本的形式建模数据。 2. 传达性：数据库结构被任何人都能理解的语言文档化。 3. 精确性：基于数据模型创建正确标准化了的结构。 ORM的概念 让我们从O/R开始。字母O起源于”对象”(Object),而R则来自于”关系”(Relational)。几乎所有的程序里面，都存在对象和关系数据库。在业务逻辑层和用户界面层中，我们是面向对象的。当对象信息发生变化的时候，我们需要把对象的信息保存在关系数据库中。当你开发一个应用程序的时候(不使用O/R Mapping),你可能会写不少数据访问层的代码，用来从数据库保存，删除，读取对象信息，等等。你在DAL中写了很多的方法来读取对象数据，改变状态对象等等任务。而这些代码写起来总是重复的。 ORM解决的主要问题是对象关系的映射。域模型和关系模型分别是建立在概念模型的基础上的。域模型是面向对象的，而关系模型是面向关系的。一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录，类的每个属性对应表的每个字段。 ORM技术特点 1.提高了开发效率。由于ORM可以自动对Entity对象与数据库中的Table进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。 2.ORM提供了对数据库的映射，不用sql直接编码，能够像操作对象一样从数据库获取数据。 ORM的优缺点 ORM的缺点是会牺牲程序的执行效率和会固定思维模式。 从系统结构上来看,采用ORM的系统一般都是多层系统，系统的层次多了，效率就会降低。ORM是一种完全的面向对象的做法，而面向对象的做法也会对性能产生一定的影响。 在我们开发系统时，一般都有性能问题。性能问题主要产生在算法不正确和与数据库不正确的使用上。ORM所生成的代码一般不太可能写出很高效的算法，在数据库应用上更有可能会被误用，主要体现在对持久对象的提取和和数据的加工处理上，如果用上了ORM,程序员很有可能将全部的数据提取到内存对象中，然后再进行过滤和加工处理，这样就容易产生性能问题。 在对对象做持久化时，ORM一般会持久化所有的属性，有时，这是不希望的。 但ORM是一种工具，工具确实能解决一些重复，简单的劳动。这是不可否认的。但我们不能指望工具能一劳永逸的解决所有问题，有些问题还是需要特殊处理的，但需要特殊处理的部分对绝大多数的系统，应该是很少的。 举例说明ORM的方便之处在不使用ORM来对数据库进行操作的时候，在完成对数据库中查询操作需要以下步骤：123456def book_list(request): db = pymysql.connect(user=&apos;me&apos;, db=&apos;mydb&apos;, passwd=&apos;122&apos;, host=&apos;localhost&apos;) cursor = db.cursor() cursor.execute(&apos;SELECT name FROM books ORDER BY name&apos;) name = [row[0] for row in cursor.fetchall() ] db.close() 使用ORM的的操作的话，不需要做连接数据库的操作，不需要去实例化cursor的实例化对象，不必去执行SQL语句，不必去取数组中的第几列，而是以一种类的方式去做这些工作。 MODELS models的简介先酷酷的甩一个官方文档的链接很气的是，语言就是没有中文的 。 模型是数据信息的唯一并明确的来源。它包含了我们储存的数据的基本字段和行为。通常，每个模型映射到一张数据库表。基本概念：1.每个模型都是django.db.models.Model的一个子类2.每个属性代表数据库中的一个字段3.在这些基础上，Django为我们提供了一个自动生成的数据库访问API。看一下例子：123456#下面的示例模型定义了一个Person,其拥有一个first_name和一个last_name属性。from django.db import models class Person(models.Model): first_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30) first_name和last_name是模型(model)的字段(fields).每个字段指定为类的一个属性，每个属性映射到数据库的一列(column)。上面的Person模型将建立类似下面这样一个数据库：12345CREATE TABLE myapp_person ( &quot;id&quot; serial NOT NULL primary_key, &quot;first_name&quot; varchar(30) NOT NULL, &quot;last_name&quot; varchar(30) NOT NULL); 关于上面代码的一些技术注释: 上面数据表的名称”myapp_person”,是从模型的元数据(metadata)自动导入的，但是可以覆写(overridden)。具体参见文档的Table names章节。 自动添加了一个id字段，该行为也可以被覆写。具体参见文档的Automatic primary_key fields章节 这是一段运用PostgreSQL语法建立数据表的SQL语句，但我们不用为此操心，针对后台settings file中设定好的数据库，Django都有量身定做的SQL。 运用模型 一旦定义好模型之后，需要告诉Django我们将使用这些模型。方法是通过编辑setting.py文件，在INSTALLED_APPS设定中添加包含了我们models.py的模块的名称。 例如，如果我们应用程序的模型存放在myapp.models模块中（该包结构在通过manage.py startapp命令创建应用程序时形成的），INSTALLED_APP应该一部分看起来如下：12345INSTALLED_APPS = [ #... &apos;myapp&apos;, #... ] 字段一个模型最重要也是唯一要求的部分，就是定义数据库的字段。字段是由类的属性指定的。注意不要选择与模型API冲突的字段名，如clean,save或者delete等。 示例:123456789101112from django.db import models class Musician(models.Model): first_name = models.CharField(max_length=50) last_name = models.CharField(max_length=50) instrument = models.CharField(max_length=100) class Album(models.Model): artist = models.ForeignKey(Musician, on_delete=models.CASCADE) name = models.CharField(max_length=100) release_date = models.DateField() num_stars = models.IntegerField() Each field in your model should be an instance of the appropriate Field class. Django uses the field class types to determine a few things: 字段类型模型的每一个字段都是相应字段类的一个实例。Django用字段类的类型来决定一些东西： 列类型（column type），告诉数据库储存什么样的数据（比如INTERGER, VARCHAR, TEXT 等）。 渲染表单字段时用默认的HTML部件（比如, 等） Django的管理系统（admin）和自动生成的表单中，运用最低的验证要求。 Django拥有许多内置的字段类型；完整的清单参见model field reference。如果内置的字段满足不了要求，我们也可以方便的编写自己的字段，具体参见Writing custom model fields。 字段选项每个字段都有一些特定的参数（参见 model field reference），例如，CharField（及其子类）要求一个最大长度参数来规定数据库VARCHAR字段的大小。 也有一些每种字段都通用的参数，都是可选的。在reference中有完整的解释，这里对最常用的一些做个快速的概览：null如果值为True,在数据库中Django将把空值储存为Null。默认值为False。 blank如果值为True,字段允许为空。默认值为False。注意它与null是不同的。null是纯粹数据库相关的，而blank是验证相关的。如果一个字段设置了blank=True, 表单验证将允许输入空值。如果设置了blank=False,该字段则是必需的。 choices一个包含了二维元组的可迭代对象（比如，列表或者元组）作为字段的选项，默认的表单部件将从标准的文本换成选择框，选项限定为choice参数。 chiices列表看起来像这样：1234567YEAR_IN_SCHOOL_CHOICES = ( (&apos;FR&apos;, &apos;Freshman&apos;), (&apos;SO&apos;, &apos;Sophomore&apos;), (&apos;JR&apos;, &apos;Junior&apos;), (&apos;SR&apos;, &apos;Senior&apos;), (&apos;GR&apos;, &apos;Graduate&apos;),) 每个元组中的第一个元素是将储存在数据库中的值。第二个元素将通过默认的表单部件显示，或者放在ModelChoiceField中。给出一个模型实例，可以通过get_FOO_display()方法来访问choices field正在显示的值。 示例：12345678910111213141516from django.db import modelsclass Person(models.Model): SHIRT_SIZES = ( (&apos;S&apos;, &apos;Small&apos;), (&apos;M&apos;, &apos;Medium&apos;), (&apos;L&apos;, &apos;Large&apos;), ) name = models.CharField(max_length=60) shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)&gt;&gt;&gt; p = Person(name=&quot;Fred Flintstone&quot;, shirt_size=&quot;L&quot;)&gt;&gt;&gt; p.save()&gt;&gt;&gt; p.shirt_size&apos;L&apos;&gt;&gt;&gt; p.get_shirt_size_display()&apos;Large&apos; default字段的默认值。可以是一个值或者一个可调用的对象。如果是后者，每次新对象创建时都会调用。help text表单部件显示附加的帮助信息。如果字段不是用在表单上，该参数对文档还是很有用的。primary_key如果值为True,该字段设为模型的主键。如果没有指定任何字段为主键，Django会自动添加一个IntegerField做为主键。所以如果不想覆写默认的主键，可以不设定任何字段的primary_key=True。主键字段是只读的，如果你改写了一个原有主键的值然后储存，旧对象的旁边将会建立一个新对象。示例如下：123456789from django.db import modelsclass Fruit(models.Model): name = models.CharField(max_length=100, primary_key=True)&gt;&gt;&gt; fruit = Fruit.objects.create(name=&apos;Apple&apos;)&gt;&gt;&gt; fruit.name = &apos;Pear&apos;&gt;&gt;&gt; fruit.save()&gt;&gt;&gt; Fruit.objects.values_list(&apos;name&apos;, flat=True)&lt;QuerySet [&apos;Apple&apos;, &apos;Pear&apos;]&gt; unique如果为True，该字段在表中必须是唯一的。再说一次，这些只是常用字段选项的简短描述，完整的信息请查看common model field option reference。 自动主键字段默认情况下，Django中每个模型都有以下字段：1id = models.AutoField(primary_key=True) 这是一个自动增长的主键。 如果你想指定一个自定义的主键，只要将某个字段的选项设置primary_key=True。如果Django发现你已经明确了字段的主键(Field.primary_key),它就不会再添加自动的id列。每个模型要求必须有一个字段设定为primary_key=True(明确指定的或者自动添加的都可以)。 详细字段名称除ForeignKey, ManyToManyField 和 OneToOneField以外，每种字段都有一个第一位置参数-详细名称。如果该详细名称没有给出，Django会自动把字段的属性名称（下划线替换成空格）作为详细名称。下面这个例子，详细名称是”person’s first name”:1first_name = models.CharField(&quot;person&apos;s first name&quot;, max_length=30) 下面这个例子，详细名称是”first name”:1first_name = models.CharField(max_length=30) ForeignKey, ManyToManyField 和 OneToOneField 要求第一位置参数为模型类，所以使用verbose_name关键字属性：1234567891011poll = models.ForeignKey( Poll, on_delete=models.CASCADE, verbose_name=&quot;the related poll&quot;,)sites = models.ManyToManyField(Site, verbose_name=&quot;list of sites&quot;)place = models.OneToOneField( Place, on_delete=models.CASCADE, verbose_name=&quot;related place&quot;,) 关系很明显，关系型数据库的能力来源于相互关联的表。Django提供了方法定义三种最常见的数据库关系：many-to-one, many-to-many and one-to-one。 一对多关系通过django.db.models.ForeignKey来定义一对多关系。我们可以像使用其他字段类型一样：将其作为类属性包含在我们的模型中。 外键（ForeignKey）要求一个位置参数：该模型关联到哪个类。 比如，一个厂家制造了很多汽车，但是每辆汽车只有一个厂家，可以如下定义：123456789from django.db import modelsclass Manufacturer(models.Model): # ... passclass Car(models.Model): manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE) # ... 你也可以创建一个递归关系recursive relationships（一个对象有一个指向自身的外键）以及与尚未定义的模型的关系relationships to models not yet defined，具体参见he model field reference。 建议，但没规定，将关联模型的小写名称作为外键字段的名称（上一个示例中的manufacturer）。当然，你可以叫外键字段任何名字，比如:123456class Car(models.Model): company_that_makes_it = models.ForeignKey( Manufacturer, on_delete=models.CASCADE, ) # ... 参考信息: 外键字段接收多种其他参数，具体参见the model field reference。这些选项帮助定义关系怎么工作，都是可选的。 关于访问向后相关（backwards-related）对象的细节，参见Following relationships backward example。 关于示例代码，参见Many-to-one relationship model example。 多对多关系要定义一个多对多关系，用MangToManyField。我们可以像使用其他字段类型一样：将其作为类属性包含在我们的模型中。MangToManyField要求一个位置参数：该模型关联到哪个类。比如，一个披萨有多种配料，一种配料也可以用在多个披萨上。可以这样描述：123456789from django.db import modelsclass Topping(models.Model): # ... passclass Pizza(models.Model): # ... toppings = models.ManyToManyField(Topping) 跟外键一样，你也可以创建递归关系以及与尚未定义的模型的关系。建议，但未规定，用关联模型对象的复数描述作为ManyToManyField的名称（上面示例中的toppings）。多对多的两个模型中哪一个设置ManyToManyField都可以，但是只能设定一个，不能都设定。通常，ManyToManyField实例会通过表单填写。在上面的示例中，tappings在Pizza中（而不是Topping有一个pizzas ManyToManyField)。因为一个有多种配料的披萨要比一种用在多个披萨上的配料要自然些。上面示例中，披萨表单中让用户可以选择配料。 参考信息:完整的示例参见Many-to-many relationship model example ManyToManyField接收多种其他参数，具体参见the model field reference。这些选项帮助定义关系怎么工作，都是可选的。 多对多关系中的额外字段当你只需要处理简单的多对多关系时，比如混合搭配披萨和配料，标准的多对多字段就够了。然而，有时候你需要两个模型之间关系的辅助数据。 例如，设想有一种程序用来追踪音乐家属于哪个乐队。人和乐队之间是一种多对多的关系，所以我们可以用一个多对多字段来描述该关系。然而，还有很多其他相关信息我们也想收集，比如某人加入某个乐队的日期。 针对这种情况，Django允许我们指定模型，用来管理该多对多关系。这样我们可以在中间模型中设置额外的字段。通过设置through参数来指出哪个模型作为媒介，将中间模型与多对多字段联合起来。我们的乐队示例，代码应该差不多像这样：1234567891011121314151617181920from django.db import modelsclass Person(models.Model): name = models.CharField(max_length=128) def __str__(self): # __unicode__ on Python 2 return self.nameclass Group(models.Model): name = models.CharField(max_length=128) members = models.ManyToManyField(Person, through=&apos;Membership&apos;) def __str__(self): # __unicode__ on Python 2 return self.nameclass Membership(models.Model): person = models.ForeignKey(Person, on_delete=models.CASCADE) group = models.ForeignKey(Group, on_delete=models.CASCADE) date_joined = models.DateField() invite_reason = models.CharField(max_length=64) 当我们建立中间模型时，我们明确指定了到该多对多关系相关模型的外键。此明确声明定义了这两个模型时怎么关联的。 中间模型中有一些约束： 中间模型必须有且只有一个到源模型（我们示例中的Group）的外键, 或者明确指定ManyToManyField.through_fields。如果有超过一个外键而且没有指定through_fields，会引发验证错误。到目标模型（我们示例中的Person）的外键也有同样的限制。 当一个模型通过中间模型到自身有多对多关系，指向同一个模型的两个外键是允许的，但是它们要按多对多关系的不同侧来处理。如果存在超过两个外键，也必须跟上面一样指定through_fields，否则会引发验证错误。 当使用中间模型定义模型到自身的多对多关系时，必须使用symmetrical=False (参照 the model field reference)。 现在我们已经设置好ManyToMany字段来使用我们的中间模型（示例中的Membership），已为建立一些多对多关系做好准备。可以通过创建中间模型的实例来实行：12345678910111213141516&gt;&gt;&gt; ringo = Person.objects.create(name=&quot;Ringo Starr&quot;)&gt;&gt;&gt; paul = Person.objects.create(name=&quot;Paul McCartney&quot;)&gt;&gt;&gt; beatles = Group.objects.create(name=&quot;The Beatles&quot;)&gt;&gt;&gt; m1 = Membership(person=ringo, group=beatles,... date_joined=date(1962, 8, 16),... invite_reason=&quot;Needed a new drummer.&quot;)&gt;&gt;&gt; m1.save()&gt;&gt;&gt; beatles.members.all()&lt;QuerySet [&lt;Person: Ringo Starr&gt;]&gt;&gt;&gt;&gt; ringo.group_set.all()&lt;QuerySet [&lt;Group: The Beatles&gt;]&gt;&gt;&gt;&gt; m2 = Membership.objects.create(person=paul, group=beatles,... date_joined=date(1960, 8, 1),... invite_reason=&quot;Wanted to form a band.&quot;)&gt;&gt;&gt; beatles.members.all()&lt;QuerySet [&lt;Person: Ringo Starr&gt;, &lt;Person: Paul McCartney&gt;]&gt; 不像普通的多对多字段，我们不可以用add(), create(), 或者 set() 去创建关系：1234&gt;&gt;&gt; # The following statements will not work&gt;&gt;&gt; beatles.members.add(john)&gt;&gt;&gt; beatles.members.create(name=&quot;George Harrison&quot;)&gt;&gt;&gt; beatles.members.set([john, paul, ringo, george]) 为什么？我们不能只创建人和乐队之间的关系，我们还需要指定Membership模型要求的关系的所有信息。简单的add, create无法指定额外的信息。所以，运用中间模型的多对多关系是禁用它们的。创建这种类型关系的唯一方法是创建中间模型的实例。 出于类似的原因, remove()方法也被禁用了。因为有时候remove()方法无法提供足够的信息来确认该删除哪一个中间模型实例：1234567&gt;&gt;&gt; Membership.objects.create(person=ringo, group=beatles,... date_joined=date(1968, 9, 4),... invite_reason=&quot;You&apos;ve been gone for a month and we miss you.&quot;)&gt;&gt;&gt; beatles.members.all()&lt;QuerySet [&lt;Person: Ringo Starr&gt;, &lt;Person: Paul McCartney&gt;, &lt;Person: Ringo Starr&gt;]&gt;&gt;&gt;&gt; # This will not work because it cannot tell which membership to remove&gt;&gt;&gt; beatles.members.remove(ringo) 然而，clear()方法可以删除一个实例的所有多对多关系：12345&gt;&gt;&gt; # Beatles have broken up&gt;&gt;&gt; beatles.members.clear()&gt;&gt;&gt; # Note that this deletes the intermediate model instances&gt;&gt;&gt; Membership.objects.all()&lt;QuerySet []&gt; 一旦通过创建中间模型实例建立了多对多关系，我们就可以进行查询了。就像普通多对多关系一样，我们可以通过相关模型的属性进行查询：123# Find all the groups with a member whose name starts with &apos;Paul&apos;&gt;&gt;&gt; Group.objects.filter(members__name__startswith=&apos;Paul&apos;)&lt;QuerySet [&lt;Group: The Beatles&gt;]&gt; 也可以通过中间模型的属性进行查询：12345# Find all the members of the Beatles that joined after 1 Jan 1961&gt;&gt;&gt; Person.objects.filter(... group__name=&apos;The Beatles&apos;,... membership__date_joined__gt=date(1961,1,1))&lt;QuerySet [&lt;Person: Ringo Starr]&gt; 如果需要访问中间模型的信息，我们可以直接对中间模型进行查询：12345&gt;&gt;&gt; ringos_membership = Membership.objects.get(group=beatles, person=ringo)&gt;&gt;&gt; ringos_membership.date_joineddatetime.date(1962, 8, 16)&gt;&gt;&gt; ringos_membership.invite_reason&apos;Needed a new drummer.&apos; 另一种访问相同信息的方法是从Person对象查询many-to-many reverse relationship：12345&gt;&gt;&gt; ringos_membership = ringo.membership_set.get(group=beatles)&gt;&gt;&gt; ringos_membership.date_joineddatetime.date(1962, 8, 16)&gt;&gt;&gt; ringos_membership.invite_reason&apos;Needed a new drummer.&apos; 一对一关系用OneToOneField定义一对一关系。像任何其他字段类型一样使用：作为属性包含在模型中。如果一个对象继承自其他对象，一对一关系最适合用于它的主键。OneToOneField要求一个位置参数：哪个模型是相关的。例如，我们要建立一个关于“处所”的数据库，可能要在数据库中建立很多标准的东西，如地址、电话号码等。这时，如果你还想在这些处所的基础上再建立一个餐厅的数据库，不必在餐厅模型中再重复指定这些字段，只需要在餐厅模型中建立一个指向处所模型的一对一字段。（因为一间餐厅也是一个处所。实际上，这种情况我们通常使用继承inheritance，它是毫无疑问的一对一关系。）跟外键一样，你也可以创建递归关系以及与尚未定义的模型的关系。参考信息:完整实例请参见One-to-one relationship model example 。一对一字段也接收一个可选的 parent_link 参数。一对一字段类以前会自动成为模型的主键，现在不是这样了（尽管可以手动设置primary_key参数，如果我们想的话）。因此，现在同一个模型中可以有多个一对一字段。 跨文件的模型访问其他应用的模型是非常容易的。 在文件顶部我们定义模型的地方，导入相关的模型就可以了。然后，无论在哪里需要的话，都可以引用它。例如：123456from django.db import modelsfrom geography.models import ZipCodeclass Restaurant(models.Model): # ... zip_code = models.ForeignKey(ZipCode) 字段命名的限制Django 对字段的命名只有两个限制： 字段的名称不能是Python 保留的关键字，因为这将导致一个Python 语法错误。例如： 12class Example(models.Model): pass = models.IntegerField() # &apos;pass&apos; is a reserved word! 由于Django 查询语法的工作方式，字段名称中连续的下划线不能超过一个。例如： 12class Example(models.Model): foo__bar = models.IntegerField() # &apos;foo__bar&apos; has two underscores! 这些限制有变通的方法，因为没有要求字段名称必须与数据库的列名匹配。参 见db_column 选项。 SQL 的保留字例如join 、where和select， 可以用作模型的字段名，因为Django 会对底层的SQL 查询语句中的数据库表名和列名进行转义。 它根据你的数据库引擎使用不同的引用语法。]]></content>
      <categories>
        <category>Django</category>
        <category>在线教育平台</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目配置流程]]></title>
    <url>%2F2018%2F02%2F05%2F%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[DATABASES配置1.创建虚拟环境 默认使用Python3.6 在cmder中输入mkvirtualenv your-virtualenv-name 。2.在pycharm中新建工程 选择工程存放的路径和指定你的虚拟环境。3.在tools中点击 run manage.py task，在 命令行中输入startapp your-app-name，为了方便管理，可以将你的app放在APPs中。4.为了在以后import方便可以将你的APPs mark成source路径，同时在setting中将APPs设置成根搜索路径。Django从请求到相应的完整流程 1.首先需要配置你的HTML页面，将你的HTML页面放在templates文件夹下，同时将你的css等静态文件放在static文件夹下。 2.根据你所要用到的数据库类型来进行数据库的连接配置，在settings中根据你自己的情况将123456DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;, &apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;), &#125;&#125; 改为你的数据库类型，因为我用的是MySQL所以我的配置如下:123456789DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &quot;Django&quot;, &apos;USER&apos;: &quot;root&quot;, &apos;PASSWORD&apos;: &quot;root&quot;, &apos;LOCALHOST&apos;: &quot;127.0.0.1&quot; &#125;&#125; 接着记得添加安装mysql的驱动mysqldb，在你的虚拟环境下1pip install mysql-python 在Windows下安装mysql驱动很容易出现错误，如果你安装的过程中出现了错误，就去传送门看一下具体的解决方案。当然，这里解决的只是Python2.x版本的。如果你是3.x版本的话，mysql-python就没有用了，解决方法就是： step:1 12#在你的虚拟环境下pip install pymysql step:2在你的pycharm工程下的__init__.py文件中添加下面的两条语句即可。 12import pymysqlpymysql.install_as_MySQLdb() 在配置完之后还要继续run manage.py task不报错就OK了。 3.生成Django需要用到的数据表123makemigrations#如果没有报错migrate 在生成表之后可以去Navicat查看。 4.运行你的项目debug你的Django项目，会出现如下信息：12345System check identified no issues (0 silenced).February 05, 2018 - 22:31:59Django version 2.0.2, using settings &apos;OLlearning.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CTRL-BREAK. 查看这个网址，会提示你你的Django可以工作啦！这个结果可能和你的不一样 ，因为这个还没没有配置URL。 TEMPLATES下的dir配置如果不配置templates的路径，那么会找不到我们的HTML文件。123456789101112131415TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, &apos;DIRS&apos;: [], &apos;APP_DIRS&apos;: True, &apos;OPTIONS&apos;: &#123; &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, ], &#125;, &#125;,] 需要将项目路径的根路径和templates做一个连接即可，如下：123456789101112131415TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, &apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)], &apos;APP_DIRS&apos;: True, &apos;OPTIONS&apos;: &#123; &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, ], &#125;, &#125;,] 新建STATICFILES_DIRS如果不对静态文件的根路径进行配置，在加载HTML文件的时候，静态文件并不会起到作用。1STATIC_URL = &apos;/static/&apos; 这样为什么还找不到我们的静态文件？因为这里还是没有配置好我们的static文件的根路径是在哪儿里。1234STATIC_URL = &apos;/static/&apos;STATICFILES_DIRS = [ os.path.join(BASE_DIR, &apos;static&apos;)] 编写views.py这个在之后的文章中会详细的写。 配置URL这个在之后的文章中会详细的写。 至此，就是项目配置的大致流程。]]></content>
      <categories>
        <category>Django</category>
        <category>在线教育平台</category>
        <category>Djando 基础知识</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发环境搭建]]></title>
    <url>%2F2018%2F02%2F02%2F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[最近学习完了bobby老师的Django打造在线教育平台，正准备学习他的Django打造生鲜电商。就想把这段时间的学习心得和重要的知识点记录一下，因为版权的原因，这里只是一些学习笔记，不会有视频资源和相关的源码。希望有兴趣的同学可以去慕课网_bobby老师的课程下学习。话不多说，开始吧！ 安装Pycharmpycharm一定要选专业版 安装MySQL和Navicatmysql安装选的是5.7.21解压免安装版，记得配置环境变量方便使用1D:\mysql-5.7.21-winx64\mysql-5.7.21-winx64\bin 这是我的安装路径，将他添加到环境变量path中就行，然后在你的cmder中键入1net start mysql 看你的数据库是否配置成功，若显示服务已启动则表示成功。Navicat同理，都有破解版。 连接MySQL遇到的问题在安装完mysql利用Navicat创建新的mysql连接的时候，可能会出现下面这种情况： 1045-Access denied for user ‘root’@’localhost’（using password:YES） 这个错误是输入密码错误的，怎么改呢？按照如下步骤执行：1.找到配置文件my.ini （我的电脑的路径：D:\mysql-5.7.21-winx64\mysql-5.7.21-winx64\bin） ，然后将其打开，可以选择用记事本打开.2.打开后，Ctrl+F 搜索[mysqld]。找到后，在[mysqld]下面添加skip-grant-tables，保存退出。PS：若提示不让保存时，可以将该文件剪切到桌面，更改保存后再复制到mySQL目录下3.保存后重启mySQL4.然后运行cmd然后就可以执行mysql命令了。输入mysql -u root -p就可以不用密码登录了，出现password：的时候直接回车可以进入，到此步骤成功连接到mysql数据库了。5.修改密码依次执行如下命令：(1)use mysql；(2) UPDATE user SET Password=PASSWORD(‘newpassword’) where USER=’root’; 因为版本的不同，5.7以上的版本会显示1ERROR 1054 (42S22): Unknown column &apos;Password&apos; in &apos;field list&apos; 是因为mysql数据库下已经没有password这个字段了，password字段改成了authentication_string，所以只要这么写就可以啦！1update mysql.user set authentication_string=password(&apos;root&apos;) where user=&apos;root&apos; (3)flush privileges;(4)quitBye;6.改好之后，再修改一下my.ini这个文件，把我们刚才加入的”skip-grant-tables”这行删除，保存退出再重启mysql服务就可以了。7.你以为错误就这样结束了？不存在的，在进行Navicat进行连接的时候会出现一个新的错误，那就是1MySQL错误号码1862：your password has expired 开心不？？？解决起来也很简单，跟随我魔鬼的步伐！12345678#开启mysql服务net start mysql#登入你的mysqlmysql -uroot -p#输入你的密码[*******]#再改一下密码SET PASSWORD = PASSWORD(&apos;root&apos;); 大功告成！这下navicat就能连接到mysql啦！ 安装Python2.7和3.6然后记得安装Python2.7和3.6的开发环境最后记得安装Python的虚拟环境virtualenv。这里说一下virtualenv的优点：1.使不同应用开发环境独立2.环境升级不影响其他应用，也不会影响全局的Python环境3.可以防止系统中出现包混乱和版本的冲突但是virtualenv的管理不太方便就需要另一款开发库virtualenvwrapper-win。123pip install virtualenvwrapper-winmkvirtualenv yourenvnamemkvirtualenv --python=your-python3.6-install-path\python.exe yourenvname 如果你想改变你存放虚拟环境的文件夹，你可以在环境变量中新建一个系统变量叫做WORKON_HOME 然后将你希望的ENVS文件夹所在的路径加进去，然后重启一下你的CMD或者CMDER就行了。]]></content>
      <categories>
        <category>Django</category>
        <category>在线教育平台</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo的逼格配置]]></title>
    <url>%2F2018%2F01%2F31%2F%E5%85%B3%E4%BA%8Ehexo%E7%9A%84%E9%80%BC%E6%A0%BC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在基础的配置之后，就想让他更酷炫一点，喏，这个就能满足你next个性化配置]]></content>
      <categories>
        <category>hexo搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[永远年轻，永远热泪盈眶]]></title>
    <url>%2F2018%2F01%2F31%2F%E8%87%B4%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;”Japhy,” I said out loud, “I don’t know when we’ll meet again or what’ll happen in the future,but Desolation, Desolation, I owe so much to Desolation. Thank you for guiding me to the place I learned all. Now comes the sadness of coming back to cities and I’ve grown two months older and there’s all that humanity of bars and burlesque shows and gritty love, all upsidedown in the void God bless them, but Japhy you and me forever know, O ever youthful, O ever weeping.” --《The Dharm Bums》]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>干下这杯酒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章插入图片]]></title>
    <url>%2F2018%2F01%2F29%2F%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[图床：完成图片的插入，这种网站就被成为图床。当博文中有图片时，若是少量图片，可以直接把图片存放在source文件夹。或者把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true，在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件，等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹，最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： ![你想输入的替代文字](xxxx/图片名.jpg) 最后检查一下，hexo g生成页面后，进入public\2018\01\29\index.html文件中查看相关字段，可以发现，html标签内的语句是: &lt;img src=&quot;2018/01/29/xxxx/图片名.jpg&quot;&gt; 而不是&lt;img src=”xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。但这显然不合理的，因为图片会占据大量的存储的空间，加载的时候相对缓慢 ，这时考虑把博文里的图片上传到某一网站，然后获得外部链接。使用Markdown语法: ![图片信息](外部链接)]]></content>
      <categories>
        <category>hexo搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>图床</tag>
      </tags>
  </entry>
</search>
