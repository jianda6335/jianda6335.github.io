<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[models的增删改查]]></title>
    <url>%2F2018%2F02%2F09%2Fmodels%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[views知识点 HttpRequest 和HttpResponseHTTP请求：HttpRequestHTTP响应：HttpResponse在django.http中。其中：GET在views.py中调用request.GET.get(“参数名”)来接收传进来的参数。在浏览器中用\?来传递参数POST 表单post提交，使用POST接收。注意，表单中的变量名要和views.py中get方法的变量名一样。123456#form 表单&lt;form method=&quot;post&quot; action=&quot;/hello/&quot;&gt;&lt;% csrf_token %&gt; &lt;input type=&quot;text&quot; value=&quot;&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 12#views.pyrequest.POST.get(&quot;name&quot;) 使用get提交,GET接收123456#form 表单&lt;form method=&quot;get&quot; action=&quot;/hello/&quot;&gt;&lt;% csrf_token %&gt; &lt;input type=&quot;text&quot; value=&quot;&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 12#views.pyrequest.GET.get(&quot;name&quot;) HttpRequest对象的属性和方法12345678910111213141516171819202122232425262728293031323334353637383940414243# path： 请求页面的全路径，不包括域名## method： 请求中使用的HTTP方法的字符串表示。全大写表示。例如## if req.method==&quot;GET&quot;:## do_something()## elseif req.method==&quot;POST&quot;:## do_something_else()## GET: 包含所有HTTP GET参数的类字典对象## POST： 包含所有HTTP POST参数的类字典对象## 服务器收到空的POST请求的情况也是可能发生的，也就是说，表单form通过# HTTP POST方法提交请求，但是表单中可能没有数据，因此不能使用# if req.POST来判断是否使用了HTTP POST 方法；应该使用 if req.method==&quot;POST&quot;#### COOKIES: 包含所有cookies的标准Python字典对象；keys和values都是字符串。## FILES： 包含所有上传文件的类字典对象；FILES中的每一个Key都是&lt;input type=&quot;file&quot; name=&quot;&quot; /&gt;标签中 name属性的值，FILES中的每一个value同时也是一个标准的python字典对象，包含下面三个Keys：## filename： 上传文件名，用字符串表示# content_type: 上传文件的Content Type# content： 上传文件的原始内容### user： 是一个django.contrib.auth.models.User对象，代表当前登陆的用户。如果访问用户当前# 没有登陆，user将被初始化为django.contrib.auth.models.AnonymousUser的实例。你# 可以通过user的is_authenticated()方法来辨别用户是否登陆：# if req.user.is_authenticated();只有激活Django中的AuthenticationMiddleware# 时该属性才可用## session： 唯一可读写的属性，代表当前会话的字典对象；自己有激活Django中的session支持时该属性才可用。#方法get_full_path(), 比如：http://127.0.0.1:8000/index33/?name=123 ,req.get_full_path()得到的结果就是/index33/?name=123req.path:/index33#注意一个常用方法：request.POST.getlist(&apos;&apos;) HTTPResponse对象对于HttpRequest对象来说，是由django自动创建的，但是，HttpResponse对象就必须我们自己创建。每个view请求处理方法必须返回一个HttpResponse对象。HttpResponse类在django.http.HttpResponse在HttpResponse对象上扩展的常用方法：12345页面渲染： render()（推荐）&lt;br&gt; render_to_response(),页面跳转： redirect(&quot;路径&quot;)locals()： 可以直接将函数中所有的变量传给模板 models 的增删改查查123456from .models import UserMessagedef getfrom(request): all_messages = UserMessage.objects.all() for message in all_messages: print(message.name) #message = UserMessage.objects.filter(name=&quot;yourname&quot;) 增12345from .models import UserMessagedef getfrom(request): user_message = UserMessage() user_message.name = &quot;北斗小辣椒&quot; user_message.save() 在对form表单提交的时候，会出现403的错误，原因就是Django的一种安全机制，解决方法就是在html中的form表单中添加1&#123;% csrf_token %&#125; 删12345678from .models import UserMessagedef getfrom(request): all_messages = UserMessage.objects.all() #删除全部 all_messages.delete() for message in all_messages: #删除一条 message.delete() 改 类似]]></content>
      <categories>
        <category>Django</category>
        <category>在线教育平台</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MODEl之meta选项]]></title>
    <url>%2F2018%2F02%2F07%2FMODEl%E4%B9%8Bmeta%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[Django 通过内嵌类class meta来给model类定义元数据（不是一个字段的任何数据” – 比如排序选项, admin 选项等等。元数据是可选的）12345class Foo(models.Model): bar = models.CharField(maxlength=30) class Meta: # ... app_labelapp_label这个选项只在一种情况下使用，就是你的模型类不在默认的应用程序包下的models.py文件中，这时候你需要指定你这个模型类是那个应用程序的。比如你在其他地方写了一个模型类，而这个模型类是属于myapp的，那么你这是需要指定为：1app_label=&apos;myapp&apos; db_tabledb_table是用于指定自定义数据库表名的。Django有一套默认的按照一定规则生成数据模型对应的数据库表名，如果你想使用自定义的表名，就通过这个属性指定，比如：1table_name=&apos;my_owner_table&apos; 若不提供该参数, Django 会使用 applabel + ‘‘ + module_name 作为表的名字。若你的表的名字是一个 SQL 保留字, 或包含 Python 变量名不允许的字符–特别是连字符 –没关系. Django 会自动在幕后替你将列名字和表名字用引号引起来. db_tablespace有些数据库有数据库表空间，比如Oracle。你可以通过db_tablespace来指定这个模型对应的数据库表放在哪个数据库表空间。 get_latest_by由于Django的管理方法中有个lastest()方法，就是得到最近一行记录。如果你的数据模型中有 DateField 或 DateTimeField 类型的字段，你可以通过这个选项来指定lastest()是按照哪个字段进行选取的。一个 DateField 或 DateTimeField 字段的名字. 若提供该选项, 该模块将拥有一个 get_latest() 函数以得到 “最新的” 对象(依据那个字段):1get_latest_by = &quot;order_date&quot; get_latest_by由于Django的管理方法中有个lastest()方法，就是得到最近一行记录。如果你的数据模型中有 DateField 或 DateTimeField 类型的字段，你可以通过这个选项来指定lastest()是按照哪个字段进行选取的。一个 DateField 或 DateTimeField 字段的名字. 若提供该选项, 该模块将拥有一个 get_latest() 函数以得到 “最新的” 对象(依据那个字段):1get_latest_by = &quot;order_date&quot; order_with_respect_to这个选项一般用于多对多的关系中，它指向一个关联对象。就是说关联对象找到这个对象后它是经过排序的。指定这个属性后你会得到一个get_XXX_order()和set_XXX_order（）的方法,通过它们你可以设置或者回去排序的对象。 举例来说, 如果一个 PizzaToppping 关联到一个 Pizza 对象, 这样做:1order_with_respect_to = &apos;pizza&apos; 就允许 toppings 依照相关的 pizza 来排序。 ordering这个字段是告诉Django模型对象返回的记录结果集是按照哪个字段排序的。比如下面的代码：12345678ordering=[&apos;order_date&apos;]# 按订单升序排列ordering=[&apos;-order_date&apos;]# 按订单降序排列，-表示降序ordering=[&apos;?order_date&apos;]# 随机排序，？表示随机ordering = [&apos;-pub_date&apos;, &apos;author&apos;]# 对 pub_date 降序,然后对 author 升序 需要注意的是:不论你使用了多少个字段排序, admin 只使用第一个字段 permissionspermissions主要是为了在Django Admin管理模块下使用的，如果你设置了这个属性可以让指定的方法权限描述更清晰可读。 要创建一个对象所需要的额外的权限. 如果一个对象有 admin 设置, 则每个对象的添加,删除和改变权限会人(依据该选项)自动创建.下面这个例子指定了一个附加权限: can_deliver_pizzas:1permissions = ((&quot;can_deliver_pizzas&quot;, &quot;Can deliver pizzas&quot;),) 这是一个2-元素 tuple 的tuple或列表, 其中两2-元素 tuple 的格式为:1(permission_code, human_readable_permission_name). unique_togetherunique_together这个选项用于：当你需要通过两个字段保持唯一性时使用。这会在 Django admin 层和数据库层同时做出限制(也就是相关的 UNIQUE 语句会被包括在 CREATE TABLE 语句中)。比如：一个Person的FirstName和LastName两者的组合必须是唯一的，那么需要这样设置：1unique_together = ((&quot;first_name&quot;, &quot;last_name&quot;),) verbose_name 和 verbose_name_pluralverbose_name的意思很简单，就是给你的模型类起一个更可读的名字：1verbose_name = &quot;pizza&quot; 若未提供该选项, Django 则会用一个类名字的 munged 版本来代替: CamelCase becomes camel case.verbose_name_plural这个选项是指定，模型的复数形式是什么，比如：1verbose_name_plural = &quot;stories&quot; 若未提供该选项, Django 会使用 verbose_name + “s”.]]></content>
      <categories>
        <category>Django</category>
        <category>在线教育平台</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django orm 和 model设计]]></title>
    <url>%2F2018%2F02%2F06%2Fdjango-orm-%E5%92%8C-model%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[ORM ORM的简介 对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。 ORM提供了实现持久化层的另一种模式，它采用映射元数据来描述对象关系的映射，使得ORM中间件能在任何一个应用的业务逻辑层和数据库层之间充当桥梁。 元数据是描述其它数据的数据 （data about other data），或者说是用于提供某种资源的有关信息的结构数据（structured data）。元数据是描述信息资源或数据等对象的数据，其使用目的在于：识别资源；评价资源；追踪资源在使用过程中的变化；实现简单高效地管理大量网络化数据；实现信息资源的有效发现、查找、一体化组织和对使用资源的有效管理。 ORM的方法论基于三个核心原则： 1. 简单：以最基本的形式建模数据。 2. 传达性：数据库结构被任何人都能理解的语言文档化。 3. 精确性：基于数据模型创建正确标准化了的结构。 ORM的概念 让我们从O/R开始。字母O起源于”对象”(Object),而R则来自于”关系”(Relational)。几乎所有的程序里面，都存在对象和关系数据库。在业务逻辑层和用户界面层中，我们是面向对象的。当对象信息发生变化的时候，我们需要把对象的信息保存在关系数据库中。当你开发一个应用程序的时候(不使用O/R Mapping),你可能会写不少数据访问层的代码，用来从数据库保存，删除，读取对象信息，等等。你在DAL中写了很多的方法来读取对象数据，改变状态对象等等任务。而这些代码写起来总是重复的。 ORM解决的主要问题是对象关系的映射。域模型和关系模型分别是建立在概念模型的基础上的。域模型是面向对象的，而关系模型是面向关系的。一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录，类的每个属性对应表的每个字段。 ORM技术特点 1.提高了开发效率。由于ORM可以自动对Entity对象与数据库中的Table进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。 2.ORM提供了对数据库的映射，不用sql直接编码，能够像操作对象一样从数据库获取数据。 ORM的优缺点 ORM的缺点是会牺牲程序的执行效率和会固定思维模式。 从系统结构上来看,采用ORM的系统一般都是多层系统，系统的层次多了，效率就会降低。ORM是一种完全的面向对象的做法，而面向对象的做法也会对性能产生一定的影响。 在我们开发系统时，一般都有性能问题。性能问题主要产生在算法不正确和与数据库不正确的使用上。ORM所生成的代码一般不太可能写出很高效的算法，在数据库应用上更有可能会被误用，主要体现在对持久对象的提取和和数据的加工处理上，如果用上了ORM,程序员很有可能将全部的数据提取到内存对象中，然后再进行过滤和加工处理，这样就容易产生性能问题。 在对对象做持久化时，ORM一般会持久化所有的属性，有时，这是不希望的。 但ORM是一种工具，工具确实能解决一些重复，简单的劳动。这是不可否认的。但我们不能指望工具能一劳永逸的解决所有问题，有些问题还是需要特殊处理的，但需要特殊处理的部分对绝大多数的系统，应该是很少的。 举例说明ORM的方便之处在不使用ORM来对数据库进行操作的时候，在完成对数据库中查询操作需要以下步骤：123456def book_list(request): db = pymysql.connect(user=&apos;me&apos;, db=&apos;mydb&apos;, passwd=&apos;122&apos;, host=&apos;localhost&apos;) cursor = db.cursor() cursor.execute(&apos;SELECT name FROM books ORDER BY name&apos;) name = [row[0] for row in cursor.fetchall() ] db.close() 使用ORM的的操作的话，不需要做连接数据库的操作，不需要去实例化cursor的实例化对象，不必去执行SQL语句，不必去取数组中的第几列，而是以一种类的方式去做这些工作。 MODELS models的简介先酷酷的甩一个官方文档的链接很气的是，语言就是没有中文的 。 模型是数据信息的唯一并明确的来源。它包含了我们储存的数据的基本字段和行为。通常，每个模型映射到一张数据库表。基本概念：1.每个模型都是django.db.models.Model的一个子类2.每个属性代表数据库中的一个字段3.在这些基础上，Django为我们提供了一个自动生成的数据库访问API。看一下例子：123456#下面的示例模型定义了一个Person,其拥有一个first_name和一个last_name属性。from django.db import models class Person(models.Model): first_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30) first_name和last_name是模型(model)的字段(fields).每个字段指定为类的一个属性，每个属性映射到数据库的一列(column)。上面的Person模型将建立类似下面这样一个数据库：12345CREATE TABLE myapp_person ( &quot;id&quot; serial NOT NULL primary_key, &quot;first_name&quot; varchar(30) NOT NULL, &quot;last_name&quot; varchar(30) NOT NULL); 关于上面代码的一些技术注释: 上面数据表的名称”myapp_person”,是从模型的元数据(metadata)自动导入的，但是可以覆写(overridden)。具体参见文档的Table names章节。 自动添加了一个id字段，该行为也可以被覆写。具体参见文档的Automatic primary_key fields章节 这是一段运用PostgreSQL语法建立数据表的SQL语句，但我们不用为此操心，针对后台settings file中设定好的数据库，Django都有量身定做的SQL。 运用模型 一旦定义好模型之后，需要告诉Django我们将使用这些模型。方法是通过编辑setting.py文件，在INSTALLED_APPS设定中添加包含了我们models.py的模块的名称。 例如，如果我们应用程序的模型存放在myapp.models模块中（该包结构在通过manage.py startapp命令创建应用程序时形成的），INSTALLED_APP应该一部分看起来如下：12345INSTALLED_APPS = [ #... &apos;myapp&apos;, #... ] 字段一个模型最重要也是唯一要求的部分，就是定义数据库的字段。字段是由类的属性指定的。注意不要选择与模型API冲突的字段名，如clean,save或者delete等。 示例:123456789101112from django.db import models class Musician(models.Model): first_name = models.CharField(max_length=50) last_name = models.CharField(max_length=50) instrument = models.CharField(max_length=100) class Album(models.Model): artist = models.ForeignKey(Musician, on_delete=models.CASCADE) name = models.CharField(max_length=100) release_date = models.DateField() num_stars = models.IntegerField() Each field in your model should be an instance of the appropriate Field class. Django uses the field class types to determine a few things: 字段类型模型的每一个字段都是相应字段类的一个实例。Django用字段类的类型来决定一些东西： 列类型（column type），告诉数据库储存什么样的数据（比如INTERGER, VARCHAR, TEXT 等）。 渲染表单字段时用默认的HTML部件（比如, 等） Django的管理系统（admin）和自动生成的表单中，运用最低的验证要求。 Django拥有许多内置的字段类型；完整的清单参见model field reference。如果内置的字段满足不了要求，我们也可以方便的编写自己的字段，具体参见Writing custom model fields。 字段选项每个字段都有一些特定的参数（参见 model field reference），例如，CharField（及其子类）要求一个最大长度参数来规定数据库VARCHAR字段的大小。 也有一些每种字段都通用的参数，都是可选的。在reference中有完整的解释，这里对最常用的一些做个快速的概览：null如果值为True,在数据库中Django将把空值储存为Null。默认值为False。 blank如果值为True,字段允许为空。默认值为False。注意它与null是不同的。null是纯粹数据库相关的，而blank是验证相关的。如果一个字段设置了blank=True, 表单验证将允许输入空值。如果设置了blank=False,该字段则是必需的。 choices一个包含了二维元组的可迭代对象（比如，列表或者元组）作为字段的选项，默认的表单部件将从标准的文本换成选择框，选项限定为choice参数。 chiices列表看起来像这样：1234567YEAR_IN_SCHOOL_CHOICES = ( (&apos;FR&apos;, &apos;Freshman&apos;), (&apos;SO&apos;, &apos;Sophomore&apos;), (&apos;JR&apos;, &apos;Junior&apos;), (&apos;SR&apos;, &apos;Senior&apos;), (&apos;GR&apos;, &apos;Graduate&apos;),) 每个元组中的第一个元素是将储存在数据库中的值。第二个元素将通过默认的表单部件显示，或者放在ModelChoiceField中。给出一个模型实例，可以通过get_FOO_display()方法来访问choices field正在显示的值。 示例：12345678910111213141516from django.db import modelsclass Person(models.Model): SHIRT_SIZES = ( (&apos;S&apos;, &apos;Small&apos;), (&apos;M&apos;, &apos;Medium&apos;), (&apos;L&apos;, &apos;Large&apos;), ) name = models.CharField(max_length=60) shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)&gt;&gt;&gt; p = Person(name=&quot;Fred Flintstone&quot;, shirt_size=&quot;L&quot;)&gt;&gt;&gt; p.save()&gt;&gt;&gt; p.shirt_size&apos;L&apos;&gt;&gt;&gt; p.get_shirt_size_display()&apos;Large&apos; default字段的默认值。可以是一个值或者一个可调用的对象。如果是后者，每次新对象创建时都会调用。help text表单部件显示附加的帮助信息。如果字段不是用在表单上，该参数对文档还是很有用的。primary_key如果值为True,该字段设为模型的主键。如果没有指定任何字段为主键，Django会自动添加一个IntegerField做为主键。所以如果不想覆写默认的主键，可以不设定任何字段的primary_key=True。主键字段是只读的，如果你改写了一个原有主键的值然后储存，旧对象的旁边将会建立一个新对象。示例如下：123456789from django.db import modelsclass Fruit(models.Model): name = models.CharField(max_length=100, primary_key=True)&gt;&gt;&gt; fruit = Fruit.objects.create(name=&apos;Apple&apos;)&gt;&gt;&gt; fruit.name = &apos;Pear&apos;&gt;&gt;&gt; fruit.save()&gt;&gt;&gt; Fruit.objects.values_list(&apos;name&apos;, flat=True)&lt;QuerySet [&apos;Apple&apos;, &apos;Pear&apos;]&gt; unique如果为True，该字段在表中必须是唯一的。再说一次，这些只是常用字段选项的简短描述，完整的信息请查看common model field option reference。 自动主键字段默认情况下，Django中每个模型都有以下字段：1id = models.AutoField(primary_key=True) 这是一个自动增长的主键。 如果你想指定一个自定义的主键，只要将某个字段的选项设置primary_key=True。如果Django发现你已经明确了字段的主键(Field.primary_key),它就不会再添加自动的id列。每个模型要求必须有一个字段设定为primary_key=True(明确指定的或者自动添加的都可以)。 详细字段名称除ForeignKey, ManyToManyField 和 OneToOneField以外，每种字段都有一个第一位置参数-详细名称。如果该详细名称没有给出，Django会自动把字段的属性名称（下划线替换成空格）作为详细名称。下面这个例子，详细名称是”person’s first name”:1first_name = models.CharField(&quot;person&apos;s first name&quot;, max_length=30) 下面这个例子，详细名称是”first name”:1first_name = models.CharField(max_length=30) ForeignKey, ManyToManyField 和 OneToOneField 要求第一位置参数为模型类，所以使用verbose_name关键字属性：1234567891011poll = models.ForeignKey( Poll, on_delete=models.CASCADE, verbose_name=&quot;the related poll&quot;,)sites = models.ManyToManyField(Site, verbose_name=&quot;list of sites&quot;)place = models.OneToOneField( Place, on_delete=models.CASCADE, verbose_name=&quot;related place&quot;,) 关系很明显，关系型数据库的能力来源于相互关联的表。Django提供了方法定义三种最常见的数据库关系：many-to-one, many-to-many and one-to-one。 一对多关系通过django.db.models.ForeignKey来定义一对多关系。我们可以像使用其他字段类型一样：将其作为类属性包含在我们的模型中。 外键（ForeignKey）要求一个位置参数：该模型关联到哪个类。 比如，一个厂家制造了很多汽车，但是每辆汽车只有一个厂家，可以如下定义：123456789from django.db import modelsclass Manufacturer(models.Model): # ... passclass Car(models.Model): manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE) # ... 你也可以创建一个递归关系recursive relationships（一个对象有一个指向自身的外键）以及与尚未定义的模型的关系relationships to models not yet defined，具体参见he model field reference。 建议，但没规定，将关联模型的小写名称作为外键字段的名称（上一个示例中的manufacturer）。当然，你可以叫外键字段任何名字，比如:123456class Car(models.Model): company_that_makes_it = models.ForeignKey( Manufacturer, on_delete=models.CASCADE, ) # ... 参考信息: 外键字段接收多种其他参数，具体参见the model field reference。这些选项帮助定义关系怎么工作，都是可选的。 关于访问向后相关（backwards-related）对象的细节，参见Following relationships backward example。 关于示例代码，参见Many-to-one relationship model example。 多对多关系要定义一个多对多关系，用MangToManyField。我们可以像使用其他字段类型一样：将其作为类属性包含在我们的模型中。MangToManyField要求一个位置参数：该模型关联到哪个类。比如，一个披萨有多种配料，一种配料也可以用在多个披萨上。可以这样描述：123456789from django.db import modelsclass Topping(models.Model): # ... passclass Pizza(models.Model): # ... toppings = models.ManyToManyField(Topping) 跟外键一样，你也可以创建递归关系以及与尚未定义的模型的关系。建议，但未规定，用关联模型对象的复数描述作为ManyToManyField的名称（上面示例中的toppings）。多对多的两个模型中哪一个设置ManyToManyField都可以，但是只能设定一个，不能都设定。通常，ManyToManyField实例会通过表单填写。在上面的示例中，tappings在Pizza中（而不是Topping有一个pizzas ManyToManyField)。因为一个有多种配料的披萨要比一种用在多个披萨上的配料要自然些。上面示例中，披萨表单中让用户可以选择配料。 参考信息:完整的示例参见Many-to-many relationship model example ManyToManyField接收多种其他参数，具体参见the model field reference。这些选项帮助定义关系怎么工作，都是可选的。 多对多关系中的额外字段当你只需要处理简单的多对多关系时，比如混合搭配披萨和配料，标准的多对多字段就够了。然而，有时候你需要两个模型之间关系的辅助数据。 例如，设想有一种程序用来追踪音乐家属于哪个乐队。人和乐队之间是一种多对多的关系，所以我们可以用一个多对多字段来描述该关系。然而，还有很多其他相关信息我们也想收集，比如某人加入某个乐队的日期。 针对这种情况，Django允许我们指定模型，用来管理该多对多关系。这样我们可以在中间模型中设置额外的字段。通过设置through参数来指出哪个模型作为媒介，将中间模型与多对多字段联合起来。我们的乐队示例，代码应该差不多像这样：1234567891011121314151617181920from django.db import modelsclass Person(models.Model): name = models.CharField(max_length=128) def __str__(self): # __unicode__ on Python 2 return self.nameclass Group(models.Model): name = models.CharField(max_length=128) members = models.ManyToManyField(Person, through=&apos;Membership&apos;) def __str__(self): # __unicode__ on Python 2 return self.nameclass Membership(models.Model): person = models.ForeignKey(Person, on_delete=models.CASCADE) group = models.ForeignKey(Group, on_delete=models.CASCADE) date_joined = models.DateField() invite_reason = models.CharField(max_length=64) 当我们建立中间模型时，我们明确指定了到该多对多关系相关模型的外键。此明确声明定义了这两个模型时怎么关联的。 中间模型中有一些约束： 中间模型必须有且只有一个到源模型（我们示例中的Group）的外键, 或者明确指定ManyToManyField.through_fields。如果有超过一个外键而且没有指定through_fields，会引发验证错误。到目标模型（我们示例中的Person）的外键也有同样的限制。 当一个模型通过中间模型到自身有多对多关系，指向同一个模型的两个外键是允许的，但是它们要按多对多关系的不同侧来处理。如果存在超过两个外键，也必须跟上面一样指定through_fields，否则会引发验证错误。 当使用中间模型定义模型到自身的多对多关系时，必须使用symmetrical=False (参照 the model field reference)。 现在我们已经设置好ManyToMany字段来使用我们的中间模型（示例中的Membership），已为建立一些多对多关系做好准备。可以通过创建中间模型的实例来实行：12345678910111213141516&gt;&gt;&gt; ringo = Person.objects.create(name=&quot;Ringo Starr&quot;)&gt;&gt;&gt; paul = Person.objects.create(name=&quot;Paul McCartney&quot;)&gt;&gt;&gt; beatles = Group.objects.create(name=&quot;The Beatles&quot;)&gt;&gt;&gt; m1 = Membership(person=ringo, group=beatles,... date_joined=date(1962, 8, 16),... invite_reason=&quot;Needed a new drummer.&quot;)&gt;&gt;&gt; m1.save()&gt;&gt;&gt; beatles.members.all()&lt;QuerySet [&lt;Person: Ringo Starr&gt;]&gt;&gt;&gt;&gt; ringo.group_set.all()&lt;QuerySet [&lt;Group: The Beatles&gt;]&gt;&gt;&gt;&gt; m2 = Membership.objects.create(person=paul, group=beatles,... date_joined=date(1960, 8, 1),... invite_reason=&quot;Wanted to form a band.&quot;)&gt;&gt;&gt; beatles.members.all()&lt;QuerySet [&lt;Person: Ringo Starr&gt;, &lt;Person: Paul McCartney&gt;]&gt; 不像普通的多对多字段，我们不可以用add(), create(), 或者 set() 去创建关系：1234&gt;&gt;&gt; # The following statements will not work&gt;&gt;&gt; beatles.members.add(john)&gt;&gt;&gt; beatles.members.create(name=&quot;George Harrison&quot;)&gt;&gt;&gt; beatles.members.set([john, paul, ringo, george]) 为什么？我们不能只创建人和乐队之间的关系，我们还需要指定Membership模型要求的关系的所有信息。简单的add, create无法指定额外的信息。所以，运用中间模型的多对多关系是禁用它们的。创建这种类型关系的唯一方法是创建中间模型的实例。 出于类似的原因, remove()方法也被禁用了。因为有时候remove()方法无法提供足够的信息来确认该删除哪一个中间模型实例：1234567&gt;&gt;&gt; Membership.objects.create(person=ringo, group=beatles,... date_joined=date(1968, 9, 4),... invite_reason=&quot;You&apos;ve been gone for a month and we miss you.&quot;)&gt;&gt;&gt; beatles.members.all()&lt;QuerySet [&lt;Person: Ringo Starr&gt;, &lt;Person: Paul McCartney&gt;, &lt;Person: Ringo Starr&gt;]&gt;&gt;&gt;&gt; # This will not work because it cannot tell which membership to remove&gt;&gt;&gt; beatles.members.remove(ringo) 然而，clear()方法可以删除一个实例的所有多对多关系：12345&gt;&gt;&gt; # Beatles have broken up&gt;&gt;&gt; beatles.members.clear()&gt;&gt;&gt; # Note that this deletes the intermediate model instances&gt;&gt;&gt; Membership.objects.all()&lt;QuerySet []&gt; 一旦通过创建中间模型实例建立了多对多关系，我们就可以进行查询了。就像普通多对多关系一样，我们可以通过相关模型的属性进行查询：123# Find all the groups with a member whose name starts with &apos;Paul&apos;&gt;&gt;&gt; Group.objects.filter(members__name__startswith=&apos;Paul&apos;)&lt;QuerySet [&lt;Group: The Beatles&gt;]&gt; 也可以通过中间模型的属性进行查询：12345# Find all the members of the Beatles that joined after 1 Jan 1961&gt;&gt;&gt; Person.objects.filter(... group__name=&apos;The Beatles&apos;,... membership__date_joined__gt=date(1961,1,1))&lt;QuerySet [&lt;Person: Ringo Starr]&gt; 如果需要访问中间模型的信息，我们可以直接对中间模型进行查询：12345&gt;&gt;&gt; ringos_membership = Membership.objects.get(group=beatles, person=ringo)&gt;&gt;&gt; ringos_membership.date_joineddatetime.date(1962, 8, 16)&gt;&gt;&gt; ringos_membership.invite_reason&apos;Needed a new drummer.&apos; 另一种访问相同信息的方法是从Person对象查询many-to-many reverse relationship：12345&gt;&gt;&gt; ringos_membership = ringo.membership_set.get(group=beatles)&gt;&gt;&gt; ringos_membership.date_joineddatetime.date(1962, 8, 16)&gt;&gt;&gt; ringos_membership.invite_reason&apos;Needed a new drummer.&apos; 一对一关系用OneToOneField定义一对一关系。像任何其他字段类型一样使用：作为属性包含在模型中。如果一个对象继承自其他对象，一对一关系最适合用于它的主键。OneToOneField要求一个位置参数：哪个模型是相关的。例如，我们要建立一个关于“处所”的数据库，可能要在数据库中建立很多标准的东西，如地址、电话号码等。这时，如果你还想在这些处所的基础上再建立一个餐厅的数据库，不必在餐厅模型中再重复指定这些字段，只需要在餐厅模型中建立一个指向处所模型的一对一字段。（因为一间餐厅也是一个处所。实际上，这种情况我们通常使用继承inheritance，它是毫无疑问的一对一关系。）跟外键一样，你也可以创建递归关系以及与尚未定义的模型的关系。参考信息:完整实例请参见One-to-one relationship model example 。一对一字段也接收一个可选的 parent_link 参数。一对一字段类以前会自动成为模型的主键，现在不是这样了（尽管可以手动设置primary_key参数，如果我们想的话）。因此，现在同一个模型中可以有多个一对一字段。 跨文件的模型访问其他应用的模型是非常容易的。 在文件顶部我们定义模型的地方，导入相关的模型就可以了。然后，无论在哪里需要的话，都可以引用它。例如：123456from django.db import modelsfrom geography.models import ZipCodeclass Restaurant(models.Model): # ... zip_code = models.ForeignKey(ZipCode) 字段命名的限制Django 对字段的命名只有两个限制： 字段的名称不能是Python 保留的关键字，因为这将导致一个Python 语法错误。例如： 12class Example(models.Model): pass = models.IntegerField() # &apos;pass&apos; is a reserved word! 由于Django 查询语法的工作方式，字段名称中连续的下划线不能超过一个。例如： 12class Example(models.Model): foo__bar = models.IntegerField() # &apos;foo__bar&apos; has two underscores! 这些限制有变通的方法，因为没有要求字段名称必须与数据库的列名匹配。参 见db_column 选项。 SQL 的保留字例如join 、where和select， 可以用作模型的字段名，因为Django 会对底层的SQL 查询语句中的数据库表名和列名进行转义。 它根据你的数据库引擎使用不同的引用语法。]]></content>
      <categories>
        <category>Django</category>
        <category>在线教育平台</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目配置流程]]></title>
    <url>%2F2018%2F02%2F05%2F%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[DATABASES配置1.创建虚拟环境 默认使用Python3.6 在cmder中输入mkvirtualenv your-virtualenv-name 。2.在pycharm中新建工程 选择工程存放的路径和指定你的虚拟环境。3.在tools中点击 run manage.py task，在 命令行中输入startapp your-app-name，为了方便管理，可以将你的app放在APPs中。4.为了在以后import方便可以将你的APPs mark成source路径，同时在setting中将APPs设置成根搜索路径。Django从请求到相应的完整流程 1.首先需要配置你的HTML页面，将你的HTML页面放在templates文件夹下，同时将你的css等静态文件放在static文件夹下。 2.根据你所要用到的数据库类型来进行数据库的连接配置，在settings中根据你自己的情况将123456DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;, &apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;), &#125;&#125; 改为你的数据库类型，因为我用的是MySQL所以我的配置如下:123456789DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &quot;Django&quot;, &apos;USER&apos;: &quot;root&quot;, &apos;PASSWORD&apos;: &quot;root&quot;, &apos;LOCALHOST&apos;: &quot;127.0.0.1&quot; &#125;&#125; 接着记得添加安装mysql的驱动mysqldb，在你的虚拟环境下1pip install mysql-python 在Windows下安装mysql驱动很容易出现错误，如果你安装的过程中出现了错误，就去传送门看一下具体的解决方案。当然，这里解决的只是Python2.x版本的。如果你是3.x版本的话，mysql-python就没有用了，解决方法就是： step:1 12#在你的虚拟环境下pip install pymysql step:2在你的pycharm工程下的__init__.py文件中添加下面的两条语句即可。 12import pymysqlpymysql.install_as_MySQLdb() 在配置完之后还要继续run manage.py task不报错就OK了。 3.生成Django需要用到的数据表123makemigrations#如果没有报错migrate 在生成表之后可以去Navicat查看。 4.运行你的项目debug你的Django项目，会出现如下信息：12345System check identified no issues (0 silenced).February 05, 2018 - 22:31:59Django version 2.0.2, using settings &apos;OLlearning.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CTRL-BREAK. 查看这个网址，会提示你你的Django可以工作啦！这个结果可能和你的不一样 ，因为这个还没没有配置URL。 TEMPLATES下的dir配置如果不配置templates的路径，那么会找不到我们的HTML文件。123456789101112131415TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, &apos;DIRS&apos;: [], &apos;APP_DIRS&apos;: True, &apos;OPTIONS&apos;: &#123; &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, ], &#125;, &#125;,] 需要将项目路径的根路径和templates做一个连接即可，如下：123456789101112131415TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, &apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)], &apos;APP_DIRS&apos;: True, &apos;OPTIONS&apos;: &#123; &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, ], &#125;, &#125;,] 新建STATICFILES_DIRS如果不对静态文件的根路径进行配置，在加载HTML文件的时候，静态文件并不会起到作用。1STATIC_URL = &apos;/static/&apos; 这样为什么还找不到我们的静态文件？因为这里还是没有配置好我们的static文件的根路径是在哪儿里。1234STATIC_URL = &apos;/static/&apos;STATICFILES_DIRS = [ os.path.join(BASE_DIR, &apos;static&apos;)] 编写views.py这个在之后的文章中会详细的写。 配置URL这个在之后的文章中会详细的写。 至此，就是项目配置的大致流程。]]></content>
      <categories>
        <category>Django</category>
        <category>在线教育平台</category>
        <category>Djando 基础知识</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发环境搭建]]></title>
    <url>%2F2018%2F02%2F02%2F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[最近学习完了bobby老师的Django打造在线教育平台，正准备学习他的Django打造生鲜电商。就想把这段时间的学习心得和重要的知识点记录一下，因为版权的原因，这里只是一些学习笔记，不会有视频资源和相关的源码。希望有兴趣的同学可以去慕课网_bobby老师的课程下学习。话不多说，开始吧！ 安装Pycharmpycharm一定要选专业版 安装MySQL和Navicatmysql安装选的是5.7.21解压免安装版，记得配置环境变量方便使用1D:\mysql-5.7.21-winx64\mysql-5.7.21-winx64\bin 这是我的安装路径，将他添加到环境变量path中就行，然后在你的cmder中键入1net start mysql 看你的数据库是否配置成功，若显示服务已启动则表示成功。Navicat同理，都有破解版。 连接MySQL遇到的问题在安装完mysql利用Navicat创建新的mysql连接的时候，可能会出现下面这种情况： 1045-Access denied for user ‘root’@’localhost’（using password:YES） 这个错误是输入密码错误的，怎么改呢？按照如下步骤执行：1.找到配置文件my.ini （我的电脑的路径：D:\mysql-5.7.21-winx64\mysql-5.7.21-winx64\bin） ，然后将其打开，可以选择用记事本打开.2.打开后，Ctrl+F 搜索[mysqld]。找到后，在[mysqld]下面添加skip-grant-tables，保存退出。PS：若提示不让保存时，可以将该文件剪切到桌面，更改保存后再复制到mySQL目录下3.保存后重启mySQL4.然后运行cmd然后就可以执行mysql命令了。输入mysql -u root -p就可以不用密码登录了，出现password：的时候直接回车可以进入，到此步骤成功连接到mysql数据库了。5.修改密码依次执行如下命令：(1)use mysql；(2) UPDATE user SET Password=PASSWORD(‘newpassword’) where USER=’root’; 因为版本的不同，5.7以上的版本会显示1ERROR 1054 (42S22): Unknown column &apos;Password&apos; in &apos;field list&apos; 是因为mysql数据库下已经没有password这个字段了，password字段改成了authentication_string，所以只要这么写就可以啦！1update mysql.user set authentication_string=password(&apos;root&apos;) where user=&apos;root&apos; (3)flush privileges;(4)quitBye;6.改好之后，再修改一下my.ini这个文件，把我们刚才加入的”skip-grant-tables”这行删除，保存退出再重启mysql服务就可以了。7.你以为错误就这样结束了？不存在的，在进行Navicat进行连接的时候会出现一个新的错误，那就是1MySQL错误号码1862：your password has expired 开心不？？？解决起来也很简单，跟随我魔鬼的步伐！12345678#开启mysql服务net start mysql#登入你的mysqlmysql -uroot -p#输入你的密码[*******]#再改一下密码SET PASSWORD = PASSWORD(&apos;root&apos;); 大功告成！这下navicat就能连接到mysql啦！ 安装Python2.7和3.6然后记得安装Python2.7和3.6的开发环境最后记得安装Python的虚拟环境virtualenv。这里说一下virtualenv的优点：1.使不同应用开发环境独立2.环境升级不影响其他应用，也不会影响全局的Python环境3.可以防止系统中出现包混乱和版本的冲突但是virtualenv的管理不太方便就需要另一款开发库virtualenvwrapper-win。123pip install virtualenvwrapper-winmkvirtualenv yourenvnamemkvirtualenv --python=your-python3.6-install-path\python.exe yourenvname 如果你想改变你存放虚拟环境的文件夹，你可以在环境变量中新建一个系统变量叫做WORKON_HOME 然后将你希望的ENVS文件夹所在的路径加进去，然后重启一下你的CMD或者CMDER就行了。]]></content>
      <categories>
        <category>Django</category>
        <category>在线教育平台</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>后端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo的逼格配置]]></title>
    <url>%2F2018%2F01%2F31%2F%E5%85%B3%E4%BA%8Ehexo%E7%9A%84%E9%80%BC%E6%A0%BC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在基础的配置之后，就想让他更酷炫一点，喏，这个就能满足你next个性化配置]]></content>
      <categories>
        <category>hexo搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[永远年轻，永远热泪盈眶]]></title>
    <url>%2F2018%2F01%2F31%2F%E8%87%B4%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;”Japhy,” I said out loud, “I don’t know when we’ll meet again or what’ll happen in the future,but Desolation, Desolation, I owe so much to Desolation. Thank you for guiding me to the place I learned all. Now comes the sadness of coming back to cities and I’ve grown two months older and there’s all that humanity of bars and burlesque shows and gritty love, all upsidedown in the void God bless them, but Japhy you and me forever know, O ever youthful, O ever weeping.” --《The Dharm Bums》]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>干下这杯酒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章插入图片]]></title>
    <url>%2F2018%2F01%2F29%2F%E6%96%87%E7%AB%A0%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[图床：完成图片的插入，这种网站就被成为图床。当博文中有图片时，若是少量图片，可以直接把图片存放在source文件夹。或者把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true，在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件，等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹，最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片： ![你想输入的替代文字](xxxx/图片名.jpg) 最后检查一下，hexo g生成页面后，进入public\2018\01\29\index.html文件中查看相关字段，可以发现，html标签内的语句是: &lt;img src=&quot;2018/01/29/xxxx/图片名.jpg&quot;&gt; 而不是&lt;img src=”xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。但这显然不合理的，因为图片会占据大量的存储的空间，加载的时候相对缓慢 ，这时考虑把博文里的图片上传到某一网站，然后获得外部链接。使用Markdown语法: ![图片信息](外部链接)]]></content>
      <categories>
        <category>hexo搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>图床</tag>
      </tags>
  </entry>
</search>
